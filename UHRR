#!/usr/bin/env python3
# -*- coding: utf-8 -*- 

import os 
import tornado.httpserver
import ssl
import tornado.ioloop
import tornado.web
import tornado.websocket
import threading
import time
import numpy 
import gc
from opus.decoder import Decoder as OpusDecoder
import datetime
import configparser
import sys
import logging
import json
import struct

# Set up comprehensive logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('uhrr_debug.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('UHRR')
# Use cross-platform Hamlib wrapper instead of direct import
try:
    from hamlib_wrapper import HamlibWrapper
    HAMLIB_AVAILABLE = True
except ImportError:
    HAMLIB_AVAILABLE = False
    print("Hamlib wrapper not available")
from rtlsdr import RtlSdr
import numpy as np
import math

# Import our new PyAudio interface
try:
    import pyaudio
    from audio_interface import PyAudioCapture, PyAudioPlayback, enumerate_audio_devices
    PYAUDIO_AVAILABLE = True
except ImportError:
    PYAUDIO_AVAILABLE = False
    print("PyAudio not available, falling back to ALSA")

############ Global variables ##################################
CTRX=None
config = configparser.ConfigParser()
config.read('UHRR.conf')
e="No"

# ATUç›¸å…³å…¨å±€å˜é‡
ATU_DEVICE_IP = '192.168.1.63'  # ç›´æ¥è®¾ç½®ATUè®¾å¤‡IPåœ°å€
ATU_DEVICE_PORT = int(os.environ.get('ATU_DEVICE_PORT', '60001'))
atu_device_connected = False
atu_ws_client = None
atu_ws_clients = []

# ATUå‘½ä»¤å®šä¹‰
SCMD_FLAG = 0xFF
SCMD_SYNC = 1
SCMD_METER_STATUS = 2

############ Global functions ##################################
def writte_log(logmsg):
	logfile = open(config['SERVER']['log_file'],"a") 
	msg = str(datetime.datetime.now())+":"+str(logmsg)
	logfile.write(msg) 
	print(msg)
	logfile.close()

############ BaseHandler tornado ##############
class BaseHandler(tornado.web.RequestHandler):
	def get_current_user(self):
		return self.get_secure_cookie("user")

############ Generate and send FFT from RTLSDR ##############
is_rtlsdr_present = True

try:
	FFTSIZE=4096
	nbBuffer=24
	nbsamples=nbBuffer/2*FFTSIZE
	ptime=nbsamples/int(config['PANADAPTER']['sample_rate'])
	sdr_windows = eval("np."+config['PANADAPTER']['fft_window']+ "(FFTSIZE)") 
	fftpaquetlen=int(FFTSIZE*8/2048)
	sdr = RtlSdr()
	sdr.sample_rate = int(config['PANADAPTER']['sample_rate']) # Hz
	sdr.center_freq = int(config['PANADAPTER']['center_freq']) # Hz
	sdr.freq_correction = int(config['PANADAPTER']['freq_correction']) # PPM
	sdr.gain = int(config['PANADAPTER']['gain']) #or 'auto'
except:
	is_rtlsdr_present = False
	

	
AudioPanaHandlerClients = []

class loadFFTdata(threading.Thread):

	def __init__(self):
		threading.Thread.__init__(self)
		self.get_log_power_spectrum_w = np.empty(FFTSIZE)
		for i in range(FFTSIZE):
			self.get_log_power_spectrum_w[i] = 0.5 * (1. - math.cos((2 * math.pi * i) / (FFTSIZE - 1)))

	def run(self):
		while True:
			time.sleep(ptime)
			self.getFFT_data()

			
	def get_log_power_spectrum(self,data):

			pulse = 10
			rejected_count = 0
			power_spectrum = np.zeros(FFTSIZE)
			db_adjust = 20. * math.log10(FFTSIZE * 2 ** 15)

			# Time-domain analysis: Often we have long normal signals interrupted
			# by huge wide-band pulses that degrade our power spectrum average.
			# We find the "normal" signal level, by computing the median of the
			# absolute value.  We only do this for the first buffer of a chunk,
			# using the median for the remaining buffers in the chunk.
			# A "noise pulse" is a signal level greater than some threshold
			# times the median.  When such a pulse is found, we skip the current
			# buffer.  It would be better to blank out just the pulse, but that
			# would be more costly in CPU time.

			# Find the median abs value of first buffer to use for this chunk.
			td_median = np.median(np.abs(data[:FFTSIZE]))
			# Calculate our current threshold relative to measured median.
			td_threshold = pulse * td_median
			nbuf_taken = 0  # Actual number of buffers accumulated
			for ic in range(nbBuffer-1):
				start=ic * int(FFTSIZE/2)
				end=start+FFTSIZE
				td_segment = data[start:end]*sdr_windows

				# remove the 0hz spike
				td_segment = np.subtract(td_segment, np.average(td_segment))

				td_max = np.amax(np.abs(td_segment))  # Do we have a noise pulse?
				if td_max < td_threshold:  # No, get pwr spectrum etc.
					# EXPERIMENTAL TAPERfd
					td_segment *= self.get_log_power_spectrum_w

					fd_spectrum = np.fft.fft(td_segment)
					# Frequency-domain:
					# Rotate array to place 0 freq. in center.  (It was at left.)
					fd_spectrum_rot = np.fft.fftshift(fd_spectrum)
					# Compute the real-valued squared magnitude (ie power) and 
					# accumulate into pwr_acc.
					# fastest way to sum |z|**2 ??
					nbuf_taken += 1
					power_spectrum = power_spectrum + \
						np.real(fd_spectrum_rot * fd_spectrum_rot.conj())
				else:  # Yes, abort buffer.
					rejected_count += 1
					# if DEBUG: print "REJECT! %d" % self.rejected_count
			if nbuf_taken > 0:
				power_spectrum = power_spectrum / nbuf_taken  # normalize the sum.
			else:
				power_spectrum = np.ones(FFTSIZE)  # if no good buffers!
			# Convert to dB. Note log(0) = "-inf" in Numpy. It can happen if ADC 
			# isn't working right. Numpy issues a warning.
			log_power_spectrum = 10. * np.log10(power_spectrum)
			return log_power_spectrum - db_adjust  # max poss. signal = 0 dB

	def getFFT_data(self):
		samples = sdr.read_samples(nbsamples)
		samples = np.imag(samples) + 1j * np.real(samples)

		max_pow = -254
		min_pow = 0

		power = self.get_log_power_spectrum(samples)

		# search whole data set for maximum and minimum value
		for dat in power:
			if dat > max_pow:
				max_pow = dat
			elif dat < min_pow:
				min_pow = dat
				
		byteslist=bytearray()
		try:
			for dat in power:
				try:
					byteslist.append(self.FFTmymap(dat, min_pow, max_pow, 0, 255))
				except (RuntimeError, TypeError, NameError):
					byteslist.append(255)
					pass
			byteslist+=bytearray((65280+int(min_pow)).to_bytes(2, byteorder="big"))
			byteslist+=bytearray((65280+int(max_pow)).to_bytes(2, byteorder="big")) 
			for c in AudioPanaHandlerClients:
				c.fftframes.append(bytes(byteslist))
		except:
			return None
		
	def FFTmymap(self, x, in_min, in_max, out_min, out_max):
		ret=int((x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min)
		return ret



class WS_panFFTHandler(tornado.websocket.WebSocketHandler):

	@tornado.gen.coroutine
	def sendFFT(self):
		global ptime, fftpaquetlen
		try:
			while len(self.fftframes)>0:
				yield self.write_message(self.fftframes[0],binary=True)
				del self.fftframes[0] 
		except:
			return None
		tornado.ioloop.IOLoop.instance().add_timeout(datetime.timedelta(seconds=ptime), self.sendFFT)

	def open(self):
		global is_rtlsdr_present
		print('new connection on FFT socket, is_rtlsdr_present = '+str(is_rtlsdr_present))
		if self not in AudioPanaHandlerClients:
			AudioPanaHandlerClients.append(self)
		self.fftframes = []
			
	def on_message(self, data) :
		print(data)
		if str(data)=="ready":
			self.sendFFT()
		elif str(data)=="init":
			self.write_message("fftsr:"+str(config['PANADAPTER']['sample_rate']));
			self.write_message("fftsz:"+str(FFTSIZE));
			self.write_message("fftst");

	def on_close(self):
		print('connection closed for FFT socket')

############ websocket for send RX audio from TRX ##############
flagWavstart = False
AudioRXHandlerClients = []

class loadWavdata(threading.Thread):

	def __init__(self):
		global flagWavstart
		threading.Thread.__init__(self)
		self.audio_capture = None
		self.inp = None
		self.audio_available = False
		
		if PYAUDIO_AVAILABLE:
			try:
				print("ğŸµ æ­£åœ¨åˆå§‹åŒ–PyAudioCapture...")
				self.audio_capture = PyAudioCapture(config)
				print("ğŸµ PyAudioCaptureå¯¹è±¡åˆ›å»ºæˆåŠŸ")
				self.inp = self.audio_capture.stream
				print("ğŸµ PyAudio streamè·å–æˆåŠŸ")
				self.audio_available = True
				# Start the PyAudioCapture thread to handle stereo processing
				print("ğŸµ æ­£åœ¨å¯åŠ¨PyAudioCaptureçº¿ç¨‹...")
				self.audio_capture.start()
				print('âœ… PyAudio audio interface initialized and stereo processing started')
			except Exception as e:
				print(f"âŒ PyAudio initialization failed: {e}")
				import traceback
				traceback.print_exc()
				print("Running without audio capture (audio devices not available)")
		else:
			# Fallback to ALSA
			try:
				import alsaaudio
				self.inp = alsaaudio.PCM(alsaaudio.PCM_CAPTURE, alsaaudio.PCM_NORMAL, channels=1, rate=8000, format=alsaaudio.PCM_FORMAT_FLOAT_LE, periodsize=256, device=config['AUDIO']['inputdevice'])
				self.audio_available = True
				print('ALSA audio interface initialized')
			except Exception as e:
				print(f"ALSA initialization failed: {e}")
				print("Running without audio capture (ALSA not available)")
				
		if self.audio_available:
			print('Audio recording ready...')
		else:
			print('Audio recording disabled - continuing with web interface only')

	def run(self):
		global Wavframes, flagWavstart
		while True:
			# Always run audio capture regardless of flagWavstart
			# The PyAudioCapture thread now handles client connection logic internally
			if not self.audio_available:
				# No audio available, just sleep
				time.sleep(0.1)
				continue
				
			if PYAUDIO_AVAILABLE and self.audio_capture:
				# PyAudioCapture thread handles all audio processing including stereo-to-mono conversion
				# The audio data is automatically sent to AudioRXHandlerClients by PyAudioCapture.run()
				# We just need to keep this thread alive
				time.sleep(0.1)
			else:
				# Fallback to ALSA
				try:
					import alsaaudio
					l, ret = self.inp.read()
					if l > 0:
						# Only send data if there are connected clients
						if len(AudioRXHandlerClients) > 0:
							for c in AudioRXHandlerClients:
								c.Wavframes.append(ret)
						logger.debug(f"ALSA: Audio data processed for {len(AudioRXHandlerClients)} clients")
					else:
						logger.debug("ALSA: audio overrun")
						time.sleep(0.01)
				except Exception as e:
					logger.error(f"ALSA read error: {e}")
					time.sleep(0.01)
				

class WS_AudioRXHandler(tornado.websocket.WebSocketHandler):

	def open(self):
		self.set_nodelay(True)
		global flagWavstart
		if self not in AudioRXHandlerClients:
			AudioRXHandlerClients.append(self)
		self.Wavframes = []
		print('new connection on AudioRXHandler socket.')
		flagWavstart = True
		self.tailstream()
		self.set_nodelay(True)
		
	@tornado.gen.coroutine
	def tailstream(self):
		while flagWavstart and self.ws_connection:
			try:
				# ç©ºé˜Ÿåˆ—æ—¶æ›´é«˜é¢‘ç‡æ£€æŸ¥ï¼Œé™ä½æŠ–åŠ¨
				while len(self.Wavframes) == 0:
					yield tornado.gen.sleep(0.005)
					if not self.ws_connection:
						return
				# å°½å¯èƒ½æŠŠå½“å‰ç´¯ç§¯çš„å¸§è¿ç»­å‘å‡ºï¼Œå‡å°‘çˆ†å‘å¼æŠ–åŠ¨
				if self.ws_connection:
					# æ¯æ¬¡æœ€å¤šå‘é€ 8 å¸§ï¼Œé¿å…é•¿æ—¶é—´é˜»å¡
					batch = 0
					while batch < 8 and len(self.Wavframes) > 0 and self.ws_connection:
						yield self.write_message(self.Wavframes[0], binary=True)
						del self.Wavframes[0]
						batch += 1
			except Exception as e:
				print(f"Error in tailstream: {e}")
				break 
			
	def on_close(self):
		if self in AudioRXHandlerClients:
			AudioRXHandlerClients.remove(self)
		global flagWavstart
		print('connection closed for audioRX')
		# Don't set flagWavstart to False - keep audio capture running
		# Audio streaming should be continuous regardless of client connections
		self.Wavframes = []
		gc.collect()

############ websocket for control TX ##############
last_AudioTXHandler_msg_time=0
AudioTXHandlerClients = []

class WS_AudioTXHandler(tornado.websocket.WebSocketHandler):

	def stoppttontimeout(self):
		global last_AudioTXHandler_msg_time
		# ä½¿ç”¨æœªæ”¶å¸§è®¡æ•°æ³•ï¼Œå‡å°‘ç¬æ—¶æŠ–åŠ¨è¯¯åˆ¤
		if not hasattr(self, 'miss_count'):
			self.miss_count = 0
		try:
			# æ¯200msæ£€æŸ¥ä¸€æ¬¡ï¼Œè¿ç»­10æ¬¡æœªæ”¶åˆ°å¸§ï¼ˆçº¦2ç§’ï¼‰åˆ™ç†„ç­PTT
			# å¢åŠ å®¹å¿åº¦ä»¥åº”å¯¹ç½‘ç»œå»¶è¿Ÿå’Œæµè§ˆå™¨å¤„ç†å»¶è¿Ÿ
			if time.time() > last_AudioTXHandler_msg_time + 0.2:
				self.miss_count += 1
				if self.miss_count >= 10 and self.ws_connection and CTRX.infos["PTT"]==True:
					CTRX.setPTT("false")
					print("stop ptt on timeout by miss_count (10x200ms)")
			else:
				self.miss_count = 0
		except:
			return None
		# Check more frequently for faster response
		tornado.ioloop.IOLoop.instance().add_timeout(datetime.timedelta(seconds=0.2), self.stoppttontimeout)


	def TX_init(self, msg) :

		itrate, is_encoded, op_rate, op_frm_dur = [int(i) for i in msg.split(',')]
		self.is_encoded = is_encoded
		if is_encoded:
			self.decoder = OpusDecoder(op_rate, 1)
			self.frame_size = op_frm_dur * op_rate

		if PYAUDIO_AVAILABLE:
			# Use PyAudio
			try:
				self.audio_playback = PyAudioPlayback(config, itrate, is_encoded, op_rate, op_frm_dur)
				logger.info(f'PyAudio TX initialized: rate={itrate}, encoded={is_encoded}')
				
				# ä½¿ç”¨PyAudio TXåˆå§‹åŒ–ä½œä¸ºå¯é çš„PTTè§¦å‘æ¡ä»¶
				# å½“PyAudio TXåˆå§‹åŒ–æˆåŠŸæ—¶ï¼Œè‡ªåŠ¨è®¾ç½®PTT=1
				global CTRX
				if CTRX and CTRX.infos.get("PTT") == False:
					logger.info("ğŸ¯ PyAudio TXåˆå§‹åŒ–æˆåŠŸï¼Œè‡ªåŠ¨è§¦å‘PTT=1")
					CTRX.setPTT("true")
					
					# å¹¿æ’­PTTçŠ¶æ€å˜åŒ–
					try:
						global ControlTRXHandlerClients
						for client in ControlTRXHandlerClients:
							client.write_message(f"getPTT:true")
					except Exception as e:
						logger.error(f"Error broadcasting PTT status: {e}")
					
			except Exception as e:
				logger.error(f'PyAudio TX initialization failed: {e}')
				raise
		else:
			# Fallback to ALSA with optimized settings for low latency
			try:
				import alsaaudio
				device = config['AUDIO']['outputdevice']
				# å‡å°periodsizeä»¥é™ä½å»¶è¿Ÿ
				self.inp = alsaaudio.PCM(alsaaudio.PCM_PLAYBACK, alsaaudio.PCM_NONBLOCK, channels=1, rate=itrate, format=alsaaudio.PCM_FORMAT_S16_LE, periodsize=512, device=device)
				logger.info(f'ALSA TX initialized: rate={itrate}, device={device}, periodsize=512')
			except Exception as e:
				logger.error(f'ALSA TX initialization failed: {e}')
				raise		
	
	def open(self):
		global last_AudioTXHandler_msg_time, AudioTXHandlerClients
		if self not in AudioTXHandlerClients:
			AudioTXHandlerClients.append(self)
			print('new connection on AudioTXHandler socket.')
		last_AudioTXHandler_msg_time=time.time()
		self.stoppttontimeout()
		self.set_nodelay(True)

	def on_message(self, data) :
		global last_AudioTXHandler_msg_time
		last_AudioTXHandler_msg_time=time.time()
		# æ”¶åˆ°æ•°æ®å³æ¸…é›¶æœªæ”¶è®¡æ•°
		if hasattr(self, 'miss_count'):
			self.miss_count = 0
		
		if str(data).startswith('m:') :
			self.TX_init(str(data[2:]))
		elif str(data).startswith('s:') :
			# ç«‹å³åœæ­¢éŸ³é¢‘æ’­æ”¾ï¼Œæ¸…é™¤ç¼“å†²åŒº
			print("ğŸ›‘ ç«‹å³åœæ­¢éŸ³é¢‘æ’­æ”¾")
			if PYAUDIO_AVAILABLE:
				if hasattr(self, 'audio_playback') and self.audio_playback:
					self.audio_playback.close()
					self.audio_playback = None
			else:
				if hasattr(self, 'inp') and self.inp:
					self.inp.close()
					self.inp = None
			# æ¸…é™¤ä»»ä½•å¾…æ’­æ”¾çš„éŸ³é¢‘æ•°æ®
			print("ğŸ§¹ æ¸…é™¤éŸ³é¢‘ç¼“å†²åŒº")
		else :
			if PYAUDIO_AVAILABLE:
				# Use PyAudio
				if hasattr(self, 'audio_playback') and self.audio_playback:
					self.audio_playback.write(data)
					gc.collect()
			else:
				# Fallback to ALSA
				if hasattr(self, 'inp') and self.inp:
					if self.is_encoded and hasattr(self, 'decoder'):
						pcm = self.decoder.decode(data, self.frame_size, False)
						self.inp.write(pcm)
						gc.collect()
					else :
						self.inp.write(data)
						gc.collect()

	def on_close(self):
		global AudioTXHandlerClients
		if PYAUDIO_AVAILABLE:
			if hasattr(self, 'audio_playback') and self.audio_playback:
				self.audio_playback.close()
		else:
			if hasattr(self, 'inp') and self.inp:
				self.inp.close()
		if self in AudioTXHandlerClients:
			AudioTXHandlerClients.remove(self)
		if (not len(AudioTXHandlerClients)) and (CTRX.infos["PTT"]==True):
			CTRX.setPTT("false")
		print('connection closed for TX socket')		

############ websocket for control TRX ##############
ControlTRXHandlerClients = []
LastPing = time.time()

# ATUå‘½ä»¤å®šä¹‰
SCMD_FLAG = 0xFF
SCMD_SYNC = 1
SCMD_METER_STATUS = 2
SCMD_TUNE_STATUS = 3
SCMD_TUNE_MODE = 4
SCMD_RELAY_STATUS = 5

# é¢„è®¾é¢‘ç‡é…ç½® - åœ¨è¿™äº›é¢‘ç‡é™„è¿‘ä¼šè‡ªåŠ¨åº”ç”¨ATUå‚æ•°
PRESET_FREQUENCIES = {
    7.050: {'sw': 0, 'inductor': 10, 'capacitor': 20},  # 7MHzé¢‘æ®µ
    14.100: {'sw': 0, 'inductor': 15, 'capacitor': 25},  # 14MHzé¢‘æ®µ
    21.100: {'sw': 1, 'inductor': 5, 'capacitor': 15},   # 21MHzé¢‘æ®µ
    28.100: {'sw': 1, 'inductor': 0, 'capacitor': 10}    # 28MHzé¢‘æ®µ
}

# å®šä¹‰ä¸»è¦æ³¢æ®µçš„ä¸­å¿ƒé¢‘ç‡
BAND_CENTERS = {
    '160m': 1.850,
    '80m': 3.550,
    '40m': 7.050,  # æ‚¨æŒ‡å®šçš„40mæ³¢æ®µä¸­å¿ƒé¢‘ç‡
    '30m': 10.100,
    '20m': 14.100,  # æ‚¨æŒ‡å®šçš„20mæ³¢æ®µä¸­å¿ƒé¢‘ç‡
    '17m': 18.100,
    '15m': 21.100,  # æ‚¨æŒ‡å®šçš„15mæ³¢æ®µä¸­å¿ƒé¢‘ç‡
    '12m': 24.900,
    '10m': 28.100   # æ‚¨æŒ‡å®šçš„10mæ³¢æ®µä¸­å¿ƒé¢‘ç‡
}

# å®šä¹‰æ¯ä¸ªæ³¢æ®µçš„é»˜è®¤ATUå‚æ•°ï¼ˆå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ï¼‰
DEFAULT_BAND_CONFIGS = {
    '160m': {'network': 'LC', 'inductor': 60, 'capacitor': 80},
    '80m': {'network': 'LC', 'inductor': 40, 'capacitor': 60},
    '40m': {'network': 'LC', 'inductor': 30, 'capacitor': 40},
    '30m': {'network': 'LC', 'inductor': 25, 'capacitor': 30},
    '20m': {'network': 'LC', 'inductor': 20, 'capacitor': 25},
    '17m': {'network': 'LC', 'inductor': 15, 'capacitor': 20},
    '15m': {'network': 'LC', 'inductor': 12, 'capacitor': 15},
    '12m': {'network': 'LC', 'inductor': 10, 'capacitor': 12},
    '10m': {'network': 'LC', 'inductor': 8, 'capacitor': 10}
}

# å½“å‰é¢‘ç‡
current_frequency = 0

# å­˜å‚¨ä¼˜åŒ–çš„è°ƒè°å‚æ•°
optimized_tuning_configs = {}  # é¢‘ç‡ -> æœ€ä½³è°ƒè°å‚æ•°çš„æ˜ å°„

# å­˜å‚¨é…ç½®æ–‡ä»¶è·¯å¾„
CONFIG_FILE = 'atu_optimized_configs.json'

# å­˜å‚¨æœ€è¿‘çš„ç”µè¡¨æ•°æ®å’Œç»§ç”µå™¨çŠ¶æ€æ•°æ®ï¼Œç”¨äºå…³è”ä¿å­˜é…ç½®
latest_meter_data = None
latest_relay_data = None

# åŠ è½½å­˜å‚¨çš„è°ƒè°é…ç½®
def load_optimized_configs():
    """ä»æ–‡ä»¶åŠ è½½å­˜å‚¨çš„è°ƒè°é…ç½®"""
    global optimized_tuning_configs
    try:
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'r') as f:
                optimized_tuning_configs = json.load(f)
            logger.info(f"âœ… å·²åŠ è½½ {len(optimized_tuning_configs)} ä¸ªå­˜å‚¨çš„è°ƒè°é…ç½®")
        else:
            logger.info("ğŸ“ è°ƒè°é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶")
    except Exception as e:
        logger.error(f"âŒ åŠ è½½è°ƒè°é…ç½®å¤±è´¥: {e}")
        optimized_tuning_configs = {}

# ä¿å­˜è°ƒè°é…ç½®åˆ°æ–‡ä»¶
def save_optimized_configs():
    """ä¿å­˜è°ƒè°é…ç½®åˆ°æ–‡ä»¶"""
    global optimized_tuning_configs
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(optimized_tuning_configs, f, indent=2)
        logger.info(f"âœ… å·²ä¿å­˜ {len(optimized_tuning_configs)} ä¸ªè°ƒè°é…ç½®åˆ°æ–‡ä»¶")
    except Exception as e:
        logger.error(f"âŒ ä¿å­˜è°ƒè°é…ç½®å¤±è´¥: {e}")

# è·å–å½“å‰é¢‘ç‡
def get_current_frequency():
    """è·å–å½“å‰é¢‘ç‡"""
    global current_frequency
    return current_frequency

# æ›´æ–°å½“å‰é¢‘ç‡
def update_current_frequency(freq):
    """æ›´æ–°å½“å‰é¢‘ç‡"""
    global current_frequency
    current_frequency = freq
    logger.info(f"ğŸ“¡ å½“å‰é¢‘ç‡æ›´æ–°ä¸º: {freq/1000000:.3f} MHz")

# åœ¨ç¨‹åºå¯åŠ¨æ—¶åŠ è½½é…ç½®
load_optimized_configs()

############ ATUè®¾å¤‡WebSocketå®¢æˆ·ç«¯ ##############
class AtuWebSocketClient:
    """ATUè®¾å¤‡WebSocketå®¢æˆ·ç«¯"""
    
    def __init__(self):
        self.ws = None
        self.running = True
        self.connected = False
        
    def connect(self):
        """è¿æ¥åˆ°ATUè®¾å¤‡WebSocket"""
        global atu_device_connected
        
        ws_url = f"ws://{ATU_DEVICE_IP}:{ATU_DEVICE_PORT}/"
        logger.info(f"å°è¯•è¿æ¥ATUè®¾å¤‡WebSocket: {ws_url}")
        
        try:
            import websocket
            self.ws = websocket.WebSocketApp(ws_url,
                                            on_open=self.on_open,
                                            on_message=self.on_message,
                                            on_error=self.on_error,
                                            on_close=self.on_close)
            
            # åœ¨åå°çº¿ç¨‹ä¸­è¿è¡ŒWebSocket
            def run_ws():
                self.ws.run_forever()
            
            ws_thread = threading.Thread(target=run_ws)
            ws_thread.daemon = True
            ws_thread.start()
            
        except Exception as e:
            logger.error(f"åˆ›å»ºWebSocketè¿æ¥å¤±è´¥: {e}")
    
    def on_open(self, ws):
        """WebSocketè¿æ¥æ‰“å¼€"""
        global atu_device_connected
        
        logger.info("âœ“ ATUè®¾å¤‡WebSocketè¿æ¥æˆåŠŸ")
        self.connected = True
        atu_device_connected = True
        
        # å‘é€è¿æ¥æˆåŠŸé€šçŸ¥
        self.broadcast_to_clients({
            'type': 'status',
            'message': 'ATUè®¾å¤‡å·²è¿æ¥',
            'connected': True
        })
        
        # å‘é€åŒæ­¥å‘½ä»¤
        self.send_sync()
        
        # å¯åŠ¨æ•°æ®è¯·æ±‚å¾ªç¯
        self.start_data_request_loop()
    
    def on_message(self, ws, message):
        """æ¥æ”¶åˆ°ATUè®¾å¤‡æ¶ˆæ¯"""
        try:
            # è§£æäºŒè¿›åˆ¶æ•°æ®
            if isinstance(message, bytes):
                data = bytearray(message)
                logger.debug(f"æ¥æ”¶åˆ°ATUæ•°æ®: {len(data)} å­—èŠ‚")
                
                # è§£ææ•°æ®
                parsed_data = self.parse_atu_data(data)
                if parsed_data:
                    # è½¬å‘ç»™WebSocketå®¢æˆ·ç«¯
                    self.broadcast_to_clients({
                        'type': 'data',
                        'data': parsed_data,
                        'timestamp': datetime.datetime.now().isoformat()
                    })
                else:
                    logger.debug("æœªè§£æåˆ°æœ‰æ•ˆçš„ATUæ•°æ®")
            
        except Exception as e:
            logger.error(f"å¤„ç†ATUæ¶ˆæ¯é”™è¯¯: {e}")
    
    def on_error(self, ws, error):
        """WebSocketé”™è¯¯"""
        logger.error(f"ATUè®¾å¤‡WebSocketé”™è¯¯: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        """WebSocketè¿æ¥å…³é—­"""
        global atu_device_connected
        
        logger.warning("ATUè®¾å¤‡WebSocketè¿æ¥å…³é—­")
        self.connected = False
        atu_device_connected = False
        
        # å‘é€è¿æ¥æ–­å¼€é€šçŸ¥
        self.broadcast_to_clients({
            'type': 'status',
            'message': 'ATUè®¾å¤‡è¿æ¥æ–­å¼€',
            'connected': False
        })
        
        # å°è¯•é‡æ–°è¿æ¥
        if self.running:
            logger.info("5ç§’åå°è¯•é‡æ–°è¿æ¥...")
            time.sleep(5)
            self.connect()
    
    def parse_atu_data(self, data):
        """è§£æATUè®¾å¤‡æ•°æ®"""
        # å£°æ˜æ‰€æœ‰éœ€è¦çš„å…¨å±€å˜é‡
        global latest_meter_data, current_frequency, latest_relay_data
        
        try:
            if len(data) < 10:
                logger.info(f"ATUæ•°æ®é•¿åº¦ä¸è¶³: {len(data)} å­—èŠ‚")
                return None
            
            # è§£æäºŒè¿›åˆ¶æ•°æ®
            flag = data[0]
            cmd = data[1]
            data_len = data[2]
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç”µè¡¨æ•°æ® (SCMD_METER_STATUS = 2)
            if cmd == SCMD_METER_STATUS and data_len >= 6:
                # è§£æåŠŸç‡å’ŒSWRæ•°æ®
                # æ­£ç¡®åç§»ï¼šSWR(4-5), åŠŸç‡(6-7), æœ€å¤§åŠŸç‡(8-9)
                swr = struct.unpack('<H', bytes(data[4:6]))[0]
                fwd_power = struct.unpack('<H', bytes(data[6:8]))[0]  # æ­£å‘åŠŸç‡
                max_power = struct.unpack('<H', bytes(data[8:10]))[0]  # æœ€å¤§åŠŸç‡
                
                # å¤„ç†SWRå€¼æ ¼å¼
                display_swr = swr
                if swr >= 100:
                    display_swr = swr / 100.0
                
                # è®¡ç®—ä¼ è¾“æ•ˆç‡
                efficiency = 0
                if max_power > 0:
                    efficiency = min(100, (fwd_power / max_power) * 100)
                
                # åˆ›å»ºå®Œæ•´æ•°æ®ç”¨äºå†…éƒ¨å¤„ç†
                full_data = {
                    'power': fwd_power,
                    'swr': round(display_swr, 2),
                    'max_power': max_power,
                    'efficiency': round(efficiency, 1)
                }
                
                logger.info(f"ğŸ“¡ ATUç”µè¡¨æ•°æ®: åŠŸç‡={fwd_power}W, SWR={display_swr}, æœ€å¤§åŠŸç‡={max_power}W, æ•ˆç‡={efficiency}%")
                
                # å­˜å‚¨æœ€æ–°çš„ç”µè¡¨æ•°æ®
                latest_meter_data = {
                    'power': fwd_power,
                    'swr': display_swr,
                    'max_power': max_power,
                    'efficiency': efficiency
                }
                
                # åˆ›å»ºåªåŒ…å«åŠŸç‡å’ŒSWRçš„ç®€åŒ–æ•°æ®ç”¨äºå‰ç«¯æ˜¾ç¤º
                parsed_data = {
                    'power': fwd_power,
                    'swr': round(display_swr, 2)
                }
                
                # å¦‚æœæœ‰åŠŸç‡è¾“å‡ºä¸”SWRè¾ƒä½ï¼Œå°è¯•ä¿å­˜ä¸ºä¼˜åŒ–é…ç½®
                if fwd_power > 0 and current_frequency > 0:
                    freq_mhz = current_frequency / 1000000.0  # è½¬æ¢ä¸ºMHz
                    # åªæœ‰å½“SWRå°äº2.0æ—¶æ‰è€ƒè™‘ä¿å­˜é…ç½®
                    if display_swr < 2.0:
                        # æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å­˜å‚¨çš„é…ç½®
                        existing_config = self.get_optimized_config(freq_mhz)
                        should_save = False
                        
                        if existing_config:
                            # å¦‚æœå½“å‰SWRæ¯”å­˜å‚¨çš„SWRæ›´å¥½ï¼Œåˆ™æ›´æ–°é…ç½®
                            stored_swr = existing_config.get('swr', 999)
                            if display_swr < stored_swr:
                                should_save = True
                                logger.info(f"ğŸ”„ é¢‘ç‡ {freq_mhz:.3f}MHz çš„SWR ({display_swr}) ä¼˜äºå­˜å‚¨çš„SWR ({stored_swr})ï¼Œå°†æ›´æ–°é…ç½®")
                        else:
                            # æ²¡æœ‰å­˜å‚¨çš„é…ç½®ï¼Œä¿å­˜å½“å‰é…ç½®
                            should_save = True
                            logger.info(f"ğŸ’¾ é¢‘ç‡ {freq_mhz:.3f}MHz æ²¡æœ‰å­˜å‚¨çš„é…ç½®ï¼Œå°†ä¿å­˜å½“å‰é…ç½®")
                        
                        if should_save:
                            # æŸ¥æ‰¾æœ€è¿‘çš„ç»§ç”µå™¨çŠ¶æ€æ•°æ®
                            if latest_relay_data:
                                logger.info(f"ğŸ’¾ ä¿å­˜é¢‘ç‡ {freq_mhz:.3f}MHz çš„ä¼˜åŒ–é…ç½®: SWR={display_swr}, ç½‘ç»œ={latest_relay_data['network']}, ç”µæ„Ÿ={latest_relay_data['inductor']}, ç”µå®¹={latest_relay_data['capacitor']}")
                                self.update_optimized_config(freq_mhz, display_swr, latest_relay_data)
                
                return parsed_data
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç»§ç”µå™¨çŠ¶æ€æ•°æ® (SCMD_RELAY_STATUS = 5)
            elif cmd == SCMD_RELAY_STATUS and data_len >= 7:
                # è§£æç»§ç”µå™¨çŠ¶æ€æ•°æ®
                sw = data[3]  # ç½‘ç»œå¼€å…³
                ind = data[4]  # ç”µæ„Ÿç»§ç”µå™¨
                cap = data[5]  # ç”µå®¹ç»§ç”µå™¨
                L = struct.unpack('<H', bytes(data[6:8]))[0]  # ç”µæ„Ÿå€¼
                C = struct.unpack('<H', bytes(data[8:10]))[0]  # ç”µå®¹å€¼
                
                # è½¬æ¢ç”µæ„Ÿå€¼ä¸ºÎ¼H (ATUè®¾å¤‡è¿”å›çš„æ˜¯100å€çš„å€¼)
                L = L / 100.0
                
                parsed_data = {
                    'relay': {
                        'network': 'CL' if sw == 1 else 'LC',
                        'inductor': ind,
                        'capacitor': cap,
                        'inductance': L,
                        'capacitance': C
                    }
                }
                
                logger.info(f"ğŸ”§ ATUç»§ç”µå™¨çŠ¶æ€: ç½‘ç»œ={parsed_data['relay']['network']}, ç”µæ„Ÿ={L}Î¼H, ç”µå®¹={C}pF")
                
                # å­˜å‚¨æœ€æ–°çš„ç»§ç”µå™¨æ•°æ®
                latest_relay_data = parsed_data['relay']
                
                return parsed_data
            
            return None
            
        except Exception as e:
            logger.error(f"è§£æATUæ•°æ®é”™è¯¯: {e}")
            return None
    
    def send_sync(self):
        """å‘é€åŒæ­¥å‘½ä»¤åˆ°ATUè®¾å¤‡"""
        if self.connected and self.ws:
            try:
                # ATUåŒæ­¥å‘½ä»¤: [0xFF, 0x01, 0x00]
                sync_command = bytearray([SCMD_FLAG, SCMD_SYNC, 0x00])
                import websocket
                self.ws.send(sync_command, opcode=websocket.ABNF.OPCODE_BINARY)
            except Exception as e:
                logger.error(f"å‘é€åŒæ­¥å‘½ä»¤å¤±è´¥: {e}")
    
    def send_tune_status(self, status):
        """å‘é€è°ƒè°çŠ¶æ€å‘½ä»¤"""
        if self.connected and self.ws:
            try:
                # ATUè°ƒè°çŠ¶æ€å‘½ä»¤: [0xFF, 0x03, 0x01, status]
                tune_command = bytearray([SCMD_FLAG, SCMD_TUNE_STATUS, 0x01, status])
                import websocket
                self.ws.send(tune_command, opcode=websocket.ABNF.OPCODE_BINARY)
                logger.info(f"ğŸ“¤ å‘é€è°ƒè°çŠ¶æ€å‘½ä»¤: {status}")
            except Exception as e:
                logger.error(f"å‘é€è°ƒè°çŠ¶æ€å‘½ä»¤å¤±è´¥: {e}")
    
    def send_tune_mode(self, mode):
        """å‘é€è°ƒè°æ¨¡å¼å‘½ä»¤"""
        if self.connected and self.ws:
            try:
                # ATUè°ƒè°æ¨¡å¼å‘½ä»¤: [0xFF, 0x04, 0x01, mode]
                tune_command = bytearray([SCMD_FLAG, SCMD_TUNE_MODE, 0x01, mode])
                import websocket
                self.ws.send(tune_command, opcode=websocket.ABNF.OPCODE_BINARY)
                logger.info(f"ğŸ“¤ å‘é€è°ƒè°æ¨¡å¼å‘½ä»¤: {mode}")
            except Exception as e:
                logger.error(f"å‘é€è°ƒè°æ¨¡å¼å‘½ä»¤å¤±è´¥: {e}")
    
    def send_relay_status(self, sw, ind, cap):
        """å‘é€ç»§ç”µå™¨çŠ¶æ€å‘½ä»¤"""
        if self.connected and self.ws:
            try:
                # ATUç»§ç”µå™¨çŠ¶æ€å‘½ä»¤: [0xFF, 0x05, 0x03, sw, ind, cap]
                relay_command = bytearray([SCMD_FLAG, SCMD_RELAY_STATUS, 0x03, sw, ind, cap])
                import websocket
                self.ws.send(relay_command, opcode=websocket.ABNF.OPCODE_BINARY)
                logger.info(f"ğŸ“¤ å‘é€ç»§ç”µå™¨çŠ¶æ€å‘½ä»¤: ç½‘ç»œ={sw}, ç”µæ„Ÿ={ind}, ç”µå®¹={cap}")
            except Exception as e:
                logger.error(f"å‘é€ç»§ç”µå™¨çŠ¶æ€å‘½ä»¤å¤±è´¥: {e}")
    
    def start_data_request_loop(self):
        """å¯åŠ¨æ•°æ®è¯·æ±‚å¾ªç¯"""
        def data_request_loop():
            while self.running and self.connected:
                try:
                    self.send_sync()
                    time.sleep(2.0)  # æ¯2ç§’å‘é€ä¸€æ¬¡è¯·æ±‚
                except Exception as e:
                    logger.error(f"æ•°æ®è¯·æ±‚å¾ªç¯é”™è¯¯: {e}")
                    break
        
        data_thread = threading.Thread(target=data_request_loop)
        data_thread.daemon = True
        data_thread.start()
    
    def broadcast_to_clients(self, message):
        """å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰WebSocketå®¢æˆ·ç«¯"""
        global atu_ws_clients
        
        logger.info(f"å‡†å¤‡å‘ {len(atu_ws_clients)} ä¸ªå®¢æˆ·ç«¯å¹¿æ’­æ¶ˆæ¯")
        
        # ä½¿ç”¨Tornadoçš„spawn_callbackç¡®ä¿åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡ŒWebSocketå†™æ“ä½œ
        def _broadcast_in_main_thread():
            sent_count = 0
            failed_clients = []
            
            # åˆ›å»ºå®¢æˆ·ç«¯åˆ—è¡¨å‰¯æœ¬ä»¥é¿å…åœ¨è¿­ä»£æ—¶ä¿®æ”¹åˆ—è¡¨
            clients_copy = atu_ws_clients[:]
            
            logger.info(f"å¼€å§‹å‘ {len(clients_copy)} ä¸ªå®¢æˆ·ç«¯å¹¿æ’­æ¶ˆæ¯: {json.dumps(message)}")
            
            for i, client in enumerate(clients_copy):
                try:
                    # æ£€æŸ¥å®¢æˆ·ç«¯è¿æ¥çŠ¶æ€
                    if hasattr(client, 'ws_connection') and client.ws_connection:
                        logger.info(f"æ­£åœ¨å‘å®¢æˆ·ç«¯ {i+1} å‘é€æ¶ˆæ¯: {json.dumps(message)}")
                        client.write_message(json.dumps(message))
                        sent_count += 1
                        logger.info(f"å®¢æˆ·ç«¯ {i+1} æ¶ˆæ¯å‘é€æˆåŠŸ")
                    else:
                        logger.warning(f"å®¢æˆ·ç«¯ {i+1} è¿æ¥å·²æ–­å¼€ï¼Œæ ‡è®°ä¸ºå¤±æ•ˆ")
                        failed_clients.append(client)
                except Exception as e:
                    logger.error(f"å‘é€æ¶ˆæ¯åˆ°å®¢æˆ·ç«¯ {i+1} å¤±è´¥: {e}")
                    # æ ‡è®°å¤±æ•ˆçš„å®¢æˆ·ç«¯
                    failed_clients.append(client)
            
            # ç§»é™¤å¤±æ•ˆçš„å®¢æˆ·ç«¯
            for client in failed_clients:
                if client in atu_ws_clients:
                    atu_ws_clients.remove(client)
                    logger.info(f"å·²ç§»é™¤å¤±æ•ˆå®¢æˆ·ç«¯ï¼Œå‰©ä½™å®¢æˆ·ç«¯æ•°: {len(atu_ws_clients)}")
            
            logger.info(f"å·²å‘ {sent_count} ä¸ªå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ï¼Œå¤±è´¥ {len(failed_clients)} ä¸ª")
            return sent_count
        
        # åœ¨Tornadoä¸»çº¿ç¨‹ä¸­æ‰§è¡Œå¹¿æ’­æ“ä½œ
        import tornado.ioloop
        tornado.ioloop.IOLoop.current().spawn_callback(_broadcast_in_main_thread)
    
    def update_optimized_config(self, frequency, swr, relay_data):
        """æ›´æ–°æŒ‡å®šé¢‘ç‡çš„ä¼˜åŒ–è°ƒè°é…ç½®"""
        global optimized_tuning_configs
        
        # æ ¼å¼åŒ–é¢‘ç‡ä¸º3ä½å°æ•°çš„å­—ç¬¦ä¸²ä½œä¸ºé”®
        freq_key = f"{frequency:.3f}"
        
        # å¦‚æœå½“å‰SWRæ¯”å­˜å‚¨çš„SWRæ›´å¥½ï¼Œåˆ™æ›´æ–°é…ç½®
        if freq_key in optimized_tuning_configs:
            stored_swr = optimized_tuning_configs[freq_key]['swr']
            if swr >= stored_swr:
                logger.info(f"ğŸ”„ é¢‘ç‡ {freq_key}MHz çš„SWR ({swr}) ä¸ä¼˜äºå­˜å‚¨çš„SWR ({stored_swr})ï¼Œè·³è¿‡æ›´æ–°")
                return
        
        # æ›´æ–°é…ç½®
        optimized_tuning_configs[freq_key] = {
            'frequency': frequency,
            'swr': swr,
            'relay': relay_data,
            'timestamp': datetime.datetime.now().isoformat()
        }
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        save_optimized_configs()
        logger.info(f"ğŸ’¾ å·²æ›´æ–°é¢‘ç‡ {freq_key}MHz çš„ä¼˜åŒ–é…ç½®: SWR={swr}, ç½‘ç»œ={relay_data.get('network')}, ç”µæ„Ÿ={relay_data.get('inductance')}Î¼H, ç”µå®¹={relay_data.get('capacitance')}pF")
    
    def get_optimized_config(self, frequency):
        """è·å–æŒ‡å®šé¢‘ç‡çš„ä¼˜åŒ–è°ƒè°é…ç½®"""
        freq_key = f"{frequency:.3f}"
        config = optimized_tuning_configs.get(freq_key)
        
        if config:
            # ç²¾ç¡®åŒ¹é…
            return config
        
        # å¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ï¼Œå°è¯•åœ¨é¢‘ç‡èŒƒå›´å†…æŸ¥æ‰¾è¿‘ä¼¼é…ç½®
        # æ‰¾åˆ°æœ€æ¥è¿‘çš„æ³¢æ®µä¸­å¿ƒ
        closest_band = None
        min_diff = float('inf')
        for band, center in BAND_CENTERS.items():
            diff = abs(frequency - center)
            if diff < min_diff:
                min_diff = diff
                closest_band = band
        
        # å¦‚æœé¢‘ç‡åœ¨æ³¢æ®µèŒƒå›´å†…ï¼ˆÂ±100kHzï¼‰ï¼ŒæŸ¥æ‰¾è¯¥æ³¢æ®µçš„é…ç½®
        if min_diff <= 0.1:  # 100kHzèŒƒå›´å†…
            for stored_freq_str, stored_config in optimized_tuning_configs.items():
                stored_freq = float(stored_freq_str)
                stored_band = None
                
                # ç¡®å®šå­˜å‚¨é…ç½®çš„æ³¢æ®µ
                for band, center in BAND_CENTERS.items():
                    if abs(stored_freq - center) <= 0.1:
                        stored_band = band
                        break
                
                # å¦‚æœå­˜å‚¨é…ç½®å’Œå½“å‰é¢‘ç‡åœ¨åŒä¸€æ³¢æ®µï¼Œè¿”å›å­˜å‚¨é…ç½®
                if stored_band == closest_band:
                    logger.info(f"ğŸ”„ åœ¨{closest_band}æ³¢æ®µæ‰¾åˆ°è¿‘ä¼¼é¢‘ç‡é…ç½®: {stored_freq:.3f}MHz -> {frequency:.3f}MHz")
                    return stored_config
        
        logger.info(f"ğŸ” é¢‘ç‡ {frequency:.3f}MHz æ²¡æœ‰åŒ¹é…çš„ä¼˜åŒ–é…ç½®")
        return None
    
    def apply_optimized_config(self, frequency):
        """åº”ç”¨æŒ‡å®šé¢‘ç‡çš„ä¼˜åŒ–è°ƒè°é…ç½®"""
        # é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å­˜å‚¨çš„ä¼˜åŒ–é…ç½®
        config = self.get_optimized_config(frequency)
        if config:
            relay_data = config.get('relay', {})
            if relay_data:
                # å‘é€ç»§ç”µå™¨çŠ¶æ€å‘½ä»¤
                network = relay_data.get('network', 'LC')
                sw = 1 if network == 'CL' else 0  # CLç½‘ç»œä¸º1ï¼ŒLCç½‘ç»œä¸º0
                inductance = relay_data.get('inductor', 0)
                capacitance = relay_data.get('capacitor', 0)
                
                logger.info(f"âš™ï¸ åº”ç”¨é¢‘ç‡ {frequency:.3f}MHz çš„ä¼˜åŒ–é…ç½®: ç½‘ç»œ={network}, ç”µæ„Ÿ={inductance}, ç”µå®¹={capacitance}")
                self.send_relay_status(sw, inductance, capacitance)
                return True
        
        # å¦‚æœæ²¡æœ‰å­˜å‚¨çš„é…ç½®ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨é¢„è®¾é¢‘ç‡èŒƒå›´å†…
        for preset_freq, preset_config in PRESET_FREQUENCIES.items():
            if abs(frequency - preset_freq) <= 0.05:  # 50kHzèŒƒå›´å†…
                logger.info(f"âš™ï¸ åº”ç”¨é¢„è®¾é¢‘ç‡ {preset_freq}MHz çš„é…ç½®: ç½‘ç»œ={'CL' if preset_config['sw'] else 'LC'}, ç”µæ„Ÿ={preset_config['inductor']}, ç”µå®¹={preset_config['capacitor']}")
                self.send_relay_status(preset_config['sw'], preset_config['inductor'], preset_config['capacitor'])
                return True
        
        # å¦‚æœä¸åœ¨é¢„è®¾é¢‘ç‡èŒƒå›´å†…ï¼ŒæŸ¥æ‰¾æœ€è¿‘çš„æ³¢æ®µå¹¶åº”ç”¨é»˜è®¤é…ç½®
        closest_band = None
        min_diff = float('inf')
        for band, center in BAND_CENTERS.items():
            diff = abs(frequency - center)
            if diff < min_diff:
                min_diff = diff
                closest_band = band
        
        # å¦‚æœé¢‘ç‡åœ¨æ³¢æ®µèŒƒå›´å†…ï¼ˆÂ±100kHzï¼‰ï¼Œåº”ç”¨è¯¥æ³¢æ®µçš„é»˜è®¤é…ç½®
        if min_diff <= 0.1 and closest_band in DEFAULT_BAND_CONFIGS:  # 100kHzèŒƒå›´å†…
            band_config = DEFAULT_BAND_CONFIGS[closest_band]
            sw = 1 if band_config['network'] == 'CL' else 0
            logger.info(f"âš™ï¸ åº”ç”¨{closest_band}æ³¢æ®µçš„é»˜è®¤é…ç½®: ç½‘ç»œ={band_config['network']}, ç”µæ„Ÿ={band_config['inductor']}, ç”µå®¹={band_config['capacitor']}")
            self.send_relay_status(sw, band_config['inductor'], band_config['capacitor'])
            return True
        
        logger.info(f"ğŸ” é¢‘ç‡ {frequency:.3f}MHz æ²¡æœ‰å¯ç”¨çš„é…ç½®")
        return False
    
    def stop(self):
        """åœæ­¢å®¢æˆ·ç«¯"""
        self.running = False
        if self.ws:
            self.ws.close()
    
    def stop(self):
        """åœæ­¢å®¢æˆ·ç«¯"""
        self.running = False
        if self.ws:
            self.ws.close()

############ ATUç›‘æ§WebSocketå¤„ç†å™¨ ##############
class AtuWebSocketHandler(tornado.websocket.WebSocketHandler):
    """ATUç›‘æ§WebSocketå¤„ç†å™¨"""
    
    def check_origin(self, origin):
        # å…è®¸è·¨åŸŸè®¿é—®
        return True
    
    def open(self):
        global atu_ws_clients
        
        if self not in atu_ws_clients:
            atu_ws_clients.append(self)
        
        logger.info(f"æ–°çš„ATUç›‘æ§å®¢æˆ·ç«¯è¿æ¥ï¼Œå½“å‰å®¢æˆ·ç«¯æ•°: {len(atu_ws_clients)}")
        logger.info(f"å®¢æˆ·ç«¯ä¿¡æ¯: {self.request.remote_ip}, {self.request.headers}")
        
        # å‘é€å½“å‰çŠ¶æ€
        self.write_message(json.dumps({
            'type': 'status',
            'message': 'è¿æ¥æˆåŠŸ',
            'connected': atu_device_connected
        }))
    
    def on_message(self, message):
        try:
            data = json.loads(message)
            
            # å¤„ç†å¿ƒè·³æ¶ˆæ¯
            if data.get('type') == 'ping':
                logger.info("æ”¶åˆ°å®¢æˆ·ç«¯å¿ƒè·³æ¶ˆæ¯")
                # å¯ä»¥é€‰æ‹©å›å¤pongæ¶ˆæ¯
                # self.write_message(json.dumps({'type': 'pong'}))
                return
            
            if data.get('type') == 'command':
                # å¤„ç†å®¢æˆ·ç«¯å‘½ä»¤
                command = data.get('command')
                if command == 'sync':
                    # å‘é€åŒæ­¥å‘½ä»¤åˆ°ATUè®¾å¤‡
                    if atu_ws_client and atu_ws_client.connected:
                        atu_ws_client.send_sync()
                elif command == 'status':
                    # è¿”å›å½“å‰çŠ¶æ€
                    self.write_message(json.dumps({
                        'type': 'status',
                        'message': 'çŠ¶æ€æŸ¥è¯¢',
                        'connected': atu_device_connected
                    }))
                elif command == 'tune_status' and 'value' in data:
                    # å‘é€è°ƒè°çŠ¶æ€å‘½ä»¤
                    if atu_ws_client and atu_ws_client.connected:
                        atu_ws_client.send_tune_status(data['value'])
                elif command == 'tune_mode' and 'value' in data:
                    # å‘é€è°ƒè°æ¨¡å¼å‘½ä»¤
                    if atu_ws_client and atu_ws_client.connected:
                        atu_ws_client.send_tune_mode(data['value'])
                elif command == 'relay_status' and 'sw' in data and 'ind' in data and 'cap' in data:
                    # å‘é€ç»§ç”µå™¨çŠ¶æ€å‘½ä»¤
                    if atu_ws_client and atu_ws_client.connected:
                        atu_ws_client.send_relay_status(data['sw'], data['ind'], data['cap'])
                elif command == 'get_optimized_config' and 'frequency' in data:
                    # è·å–ä¼˜åŒ–é…ç½®
                    config = atu_ws_client.get_optimized_config(data['frequency'])
                    self.write_message(json.dumps({
                        'type': 'optimized_config',
                        'frequency': data['frequency'],
                        'config': config
                    }))
                elif command == 'apply_optimized_config' and 'frequency' in data:
                    # åº”ç”¨ä¼˜åŒ–é…ç½®
                    success = atu_ws_client.apply_optimized_config(data['frequency'])
                    self.write_message(json.dumps({
                        'type': 'apply_config_result',
                        'frequency': data['frequency'],
                        'success': success
                    }))
                elif command == 'save_optimized_config' and 'frequency' in data and 'swr' in data and 'relay' in data:
                    # ä¿å­˜ä¼˜åŒ–é…ç½®
                    atu_ws_client.update_optimized_config(data['frequency'], data['swr'], data['relay'])
                    self.write_message(json.dumps({
                        'type': 'config_saved',
                        'frequency': data['frequency']
                    }))
                elif command == 'update_frequency' and 'frequency' in data:
                    # æ›´æ–°å½“å‰é¢‘ç‡
                    update_current_frequency(data['frequency'])
                    self.write_message(json.dumps({
                        'type': 'frequency_updated',
                        'frequency': data['frequency']
                    }))
                elif command == 'get_optimized_config' and 'frequency' in data:
                    # è·å–ä¼˜åŒ–é…ç½®
                    config = atu_ws_client.get_optimized_config(data['frequency'])
                    self.write_message(json.dumps({
                        'type': 'optimized_config',
                        'frequency': data['frequency'],
                        'config': config
                    }))
                elif command == 'apply_optimized_config' and 'frequency' in data:
                    # åº”ç”¨ä¼˜åŒ–é…ç½®
                    success = atu_ws_client.apply_optimized_config(data['frequency'])
                    self.write_message(json.dumps({
                        'type': 'apply_config_result',
                        'frequency': data['frequency'],
                        'success': success
                    }))
                elif command == 'save_optimized_config' and 'frequency' in data and 'swr' in data and 'relay' in data:
                    # ä¿å­˜ä¼˜åŒ–é…ç½®
                    atu_ws_client.update_optimized_config(data['frequency'], data['swr'], data['relay'])
                    self.write_message(json.dumps({
                        'type': 'config_saved',
                        'frequency': data['frequency']
                    }))
                    
        except Exception as e:
            logger.error(f"å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯é”™è¯¯: {e}")
    
    def on_close(self):
        global atu_ws_clients
        
        # è®°å½•å®¢æˆ·ç«¯æ–­å¼€è¿æ¥çš„è¯¦ç»†ä¿¡æ¯
        logger.info(f"ATUç›‘æ§å®¢æˆ·ç«¯æ–­å¼€è¿æ¥ï¼Œå®¢æˆ·ç«¯ID: {id(self)}, å‰©ä½™å®¢æˆ·ç«¯æ•°: {len(atu_ws_clients)}")
        
        if self in atu_ws_clients:
            atu_ws_clients.remove(self)
        
        logger.info(f"ATUç›‘æ§å®¢æˆ·ç«¯æ¸…ç†å®Œæˆï¼Œå‰©ä½™å®¢æˆ·ç«¯æ•°: {len(atu_ws_clients)}")

############ ATUç›‘æ§é¡µé¢å¤„ç†å™¨ ##############
class AtuMonitorHandler(tornado.web.RequestHandler):
    """ATUç›‘æ§é¡µé¢å¤„ç†å™¨"""
    
    def get(self):
        try:
            # è¯»å–ATUç›‘æ§é¡µé¢
            with open("www/atu_monitor.html", "r") as f:
                content = f.read()
            self.write(content)
        except Exception as e:
            logger.error(f"è¯»å–ATUç›‘æ§é¡µé¢å¤±è´¥: {e}")
            self.write("<html><body><h1>ATUç›‘æ§ç³»ç»Ÿ</h1><p>é¡µé¢åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨æ—¥å¿—ã€‚</p></body></html>")

############ ATUçŠ¶æ€APIå¤„ç†å™¨ ##############
class AtuStatusHandler(tornado.web.RequestHandler):
    """ATUçŠ¶æ€APIå¤„ç†å™¨"""
    
    def get(self):
        global atu_device_connected
        
        status = {
            'atu_device_connected': atu_device_connected,
            'atu_device_ip': ATU_DEVICE_IP,
            'atu_device_port': ATU_DEVICE_PORT,
            'websocket_clients': len(atu_ws_clients),
            'server_time': datetime.datetime.now().isoformat()
        }
        
        self.set_header('Content-Type', 'application/json')
        self.write(json.dumps(status))

class TRXRIG:
	def __init__(self):
		global HAMLIB_AVAILABLE
		self.spoints = {"0":-54, "1":-48, "2":-42, "3":-36, "4":-30, "5":-24, "6":-18, "7":-12, "8":-6, "9":0, "10":10, "20":20, "30":30, "40":40, "50":50, "60":60}
		self.infos = {}
		self.infos["PTT"]=False
		self.infos["powerstat"]=False
		self.rig = None
		
		# Use rigctld daemon for persistent connection
		if HAMLIB_AVAILABLE:
			try:
				# Test if rigctld daemon is running
				logger.info("Testing rigctld daemon connection...")
				import socket
				
				# Test connection to rigctld
				try:
					sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
					sock.settimeout(2)
					sock.connect(('127.0.0.1', 4532))
					sock.sendall(b"f\n")
					response = sock.recv(1024).decode().strip()
					sock.close()
					
					logger.info(f"âœ“ rigctld daemon responding! Initial frequency: {response}")
					self.rig = "rigctld_daemon"  # Use daemon approach
					self.rigctld_host = "127.0.0.1"
					self.rigctld_port = 4532
					
				except socket.error as e:
					logger.error(f"âš  rigctld daemon not running: {e}")
					logger.info("Please start rigctld with: rigctld -m 30003 -r /dev/cu.usbserial-230 -s 4800 -C stop_bits=2 -T 127.0.0.1 -t 4532")
					self.rig = None
					
			except Exception as e:
				logger.error(f"Could not initialize radio control: {e}")
				self.rig = None
		else:
			logger.warning("Hamlib not available")
			self.rig = None
		
		# Initialize default values - use realistic IC-M710 frequency  
		self.infos["FREQ"] = 7200000  # 7.200 MHz (40m band)
		self.infos["MODE"] = "USB"
		self.infos["VFO"] = 0
		self.infos["StrgLVL"] = "0"
		self.infos["PTT"] = False
		
		if self.rig:
			print("Radio control initialized successfully")
			# Get initial values from radio
			self.setPower(1)
			self.getvfo()
			self.getFreq()
			self.getMode()
			# PTT monitoring disabled to reduce rigctld load
		else:
			print("Running in simulation mode - radio commands will be simulated")
		
	def _rigctld_command(self, cmd):
		"""Send command to rigctld daemon and return the result"""
		#logger.debug(f"Sending rigctld command: {cmd}")
		if not self.rig or self.rig != "rigctld_daemon":
			logger.error(f"Rigctld not available for command: {cmd}")
			return None
		try:
			import socket
			sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			sock.settimeout(3)
			sock.connect(('127.0.0.1', 4532))
			sock.sendall((cmd + '\n').encode())
			response = sock.recv(1024).decode().strip()
			sock.close()
			#logger.debug(f"rigctld response to '{cmd}': {response}")
			#logger.debug(f"rigctld command '{cmd}' successful")
			return response
		except Exception as e:
			logger.error(f"Error communicating with rigctld for command '{cmd}': {e}")
			return None
	
	def _rigctld_set_command(self, cmd, value):
		"""Send set command to rigctld daemon"""
		logger.info(f"Sending rigctld set command: {cmd} {value}")
		if not self.rig or self.rig != "rigctld_daemon":
			logger.error(f"Rigctld not available for set command: {cmd} {value}")
			return False
		try:
			import socket
			sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			sock.settimeout(3)
			sock.connect(('127.0.0.1', 4532))
			command = f"{cmd} {value}\n"
			sock.sendall(command.encode())
			response = sock.recv(1024).decode().strip()
			sock.close()
			logger.debug(f"rigctld set response to '{cmd} {value}': {response}")
			if response == "RPRT 0":
				logger.info(f"rigctld set command '{cmd} {value}' successful")
				return True
			else:
				logger.error(f"rigctld set command '{cmd} {value}' failed: {response}")
				return False
		except Exception as e:
			logger.error(f"Error communicating with rigctld for set command '{cmd} {value}': {e}")
			return False
	
	def _rigctld_mode_command(self, mode_cmd):
		"""Send mode command to rigctld daemon"""
		logger.info(f"Sending rigctld mode command: {mode_cmd}")
		try:
			import socket
			sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			sock.settimeout(3)
			sock.connect(('127.0.0.1', 4532))
			sock.sendall((mode_cmd + '\n').encode())
			response = sock.recv(1024).decode().strip()
			sock.close()
			logger.debug(f"rigctld mode response to '{mode_cmd}': {response}")
			if response == "RPRT 0":
				logger.info(f"rigctld mode command '{mode_cmd}' successful")
				return True
			else:
				logger.error(f"rigctld mode command '{mode_cmd}' failed: {response}")
				return False
		except Exception as e:
			logger.error(f"Error communicating with rigctld for mode command '{mode_cmd}': {e}")
			return False
	
	def _get_default_passband(self, mode):
		"""Get default passband for mode"""
		passbands = {
			"USB": 2400,
			"LSB": 2400, 
			"AM": 6000,
			"FM": 12000,
			"CW": 500,
			"RTTY": 2200
		}
		return passbands.get(mode.upper(), 2400)
		
	def test_radio_communication(self):
		"""Test basic communication with the radio"""
		try:
			# Try to get frequency as a basic connectivity test
			test_freq = self.getFreq()
			logger.info(f"Radio communication test - Current frequency: {test_freq} Hz")
			if test_freq > 0:
				logger.info("âœ“ Radio is responding and appears to be powered on")
			else:
				logger.warning("âš  Radio connected but may be powered off (frequency = 0)")
		except Exception as e:
			logger.error(f"Radio communication test failed: {e}")
	
	def parsedbtospoint(self,spoint):
		for key, value in self.spoints.items():
			if (spoint<value):
				return key
				break
				
		
	def getvfo(self):
		if self.rig == "rigctl_subprocess":
			# IC-M710 typically has one VFO, set to default
			self.infos["VFO"] = 1  # VFO A
			print("IC-M710 VFO set to default (VFO A)")
		elif self.rig == "rigctld_daemon":
			# For IC-M710 with rigctld, we'll use a default VFO
			self.infos["VFO"] = 1  # VFO A
			print("IC-M710 VFO set to default (VFO A) with rigctld")
		elif not self.rig:
			return self.infos.get("VFO", 0)
		else:
			try:
				vfo = self.rig.rig_get_vfo()
				if vfo is not None:
					self.infos["VFO"] = vfo
					print(f"Current VFO: {vfo}")
				else:
					print("Could not obtain VFO from radio")
			except Exception as e:
				print(f"Error getting VFO: {e}")
		return self.infos.get("VFO", 0)

	def setFreq(self, frequency):
		frequency = int(float(frequency))  # Ensure integer frequency
		if self.rig == "rigctld_daemon":
			if self._rigctld_set_command("F", frequency):
				self.infos["FREQ"] = frequency
				logger.info(f"âœ“ Frequency set to {frequency} Hz via rigctld")
			else:
				logger.error(f"âœ— Failed to set frequency to {frequency} Hz via rigctld")
		elif not self.rig:
			self.infos["FREQ"] = frequency
			logger.info(f"Simulated: Frequency set to {frequency} Hz")
		else:
			try:
				vfo = self.infos.get("VFO", 1)  # Default to VFO A
				result = self.rig.rig_set_freq(vfo, float(frequency))
				if result == 0:
					self.infos["FREQ"] = frequency
					logger.info(f"Frequency set to {frequency} Hz")
				else:
					logger.error(f"Failed to set frequency, error code: {result}")
			except Exception as e:
				logger.error(f"Error setting frequency: {e}")
		return self.infos.get("FREQ", 7200000)
		
	def getFreq(self):
		if self.rig == "rigctld_daemon":
			freq_str = self._rigctld_command("f")
			if freq_str:
				try:
					freq = int(float(freq_str))  # Convert to int to avoid display issues
					self.infos["FREQ"] = freq
					logger.info(f"Current frequency from rigctld: {freq} Hz")
					return freq
				except ValueError:
					logger.error(f"Invalid frequency response from rigctld: {freq_str}")
		elif not self.rig:
			return self.infos.get("FREQ", 7200000)
		else:
			try:
				vfo = self.infos.get("VFO", 1)  # Default to VFO A
				freq = self.rig.rig_get_freq(vfo)
				if freq is not None and freq > 0:
					self.infos["FREQ"] = int(freq)  # Convert to int
					logger.info(f"Current frequency: {int(freq)} Hz")
				else:
					logger.warning("Could not obtain frequency from radio (radio may be off or not responding)")
			except Exception as e:
				logger.error(f"Error getting frequency: {e}")
		return self.infos.get("FREQ", 7200000)
		
	def setMode(self,MODE):
		logger.info(f"Setting mode to: {MODE}")
		if self.rig == "rigctld_daemon":
			# IC-M710 may have limited mode support - try setting but handle gracefully
			pb = self._get_default_passband(MODE)
			mode_cmd = f"M {MODE.upper()} {pb}"
			try:
				import socket
				sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				sock.settimeout(3)
				sock.connect(('127.0.0.1', 4532))
				sock.sendall((mode_cmd + '\n').encode())
				response = sock.recv(1024).decode().strip()
				sock.close()
				logger.debug(f"rigctld mode response to '{mode_cmd}': {response}")
				if response == "RPRT 0":
					self.infos["MODE"] = MODE.upper()
					logger.info(f"âœ“ Mode set to {MODE} via rigctld")
				else:
					# IC-M710 may not support mode setting via CAT - store locally
					logger.warning(f"Mode setting failed via CAT: {response}, storing locally")
					self.infos["MODE"] = MODE.upper()
					logger.info(f"Mode stored as {MODE} (manual radio adjustment may be needed)")
			except Exception as e:
				logger.error(f"Error communicating with rigctld for mode command '{mode_cmd}': {e}")
				# Fallback - store mode locally
				self.infos["MODE"] = MODE.upper() 
				logger.info(f"Mode stored as {MODE} due to error (manual radio adjustment may be needed)")
		elif not self.rig:
			self.infos["MODE"] = MODE
			logger.info(f"Simulated: Mode set to {MODE}")
		else:
			try:
				vfo = self.infos.get("VFO", 1)  # Default to VFO A
				# Convert mode string to Hamlib mode constant
				mode_map = {
					"LSB": 1, "USB": 2, "CW": 3, "FM": 4, "AM": 5,
					"RTTY": 6, "CWR": 7, "RTTYR": 8, "AMS": 9
				}
				hamlib_mode = mode_map.get(MODE.upper(), 2)  # Default to USB
				pb = 0  # Use default passband
				
				result = self.rig.rig_set_mode(vfo, hamlib_mode, pb)
				if result == 0:
					self.infos["MODE"] = MODE
					logger.info(f"Mode set to {MODE}")
				else:
					logger.error(f"Failed to set mode, error code: {result}")
			except Exception as e:
				logger.error(f"Error setting mode: {e}")
		return self.infos.get("MODE", "USB")
		
	def getMode(self):
		if self.rig == "rigctld_daemon":
			# Note: IC-M710 may not fully support mode query via Hamlib
			# rigctld sometimes returns only passband instead of mode
			mode_str = self._rigctld_command("m")
			if mode_str:
				try:
					# rigctld may return "MODE PASSBAND" or just "PASSBAND"
					mode_str = mode_str.strip()
					logger.debug(f"Raw mode response: '{mode_str}'")
					
					# If response is just a number (passband), use stored mode
					if mode_str.isdigit():
						logger.warning(f"IC-M710 returned only passband {mode_str}, using stored mode {self.infos.get('MODE', 'USB')}")
						return self.infos.get("MODE", "USB")
						
					mode_parts = mode_str.split()
					if mode_parts:
						mode = mode_parts[0].strip().upper()
						# Map rigctl mode names to standard names
						mode_map = {
							"PKTUSB": "USB", "PKTLSB": "LSB", "DATA": "USB",
							"DIG": "USB", "RTTY": "USB", "PSK": "USB"
						}
						mode = mode_map.get(mode, mode)
						self.infos["MODE"] = mode
						logger.info(f"Current mode from rigctld: {mode}")
						return mode
				except Exception as e:
					logger.error(f"Error parsing mode response '{mode_str}': {e}")
		elif not self.rig:
			return self.infos.get("MODE", "USB")
		else:
			try:
				vfo = self.infos.get("VFO", 1)  # Default to VFO A
				mode, passband = self.rig.rig_get_mode(vfo)
				if mode >= 0:
					# Convert Hamlib mode constant to string
					mode_map = {
						1: "LSB", 2: "USB", 3: "CW", 4: "FM", 5: "AM",
						6: "RTTY", 7: "CWR", 8: "RTTYR", 9: "AMS"
					}
					mode_str = mode_map.get(mode, "USB")
					self.infos["MODE"] = mode_str
					self.infos["WIDTH"] = passband
					logger.info(f"Current mode: {mode_str}, passband: {passband}")
					return mode_str
				else:
					logger.error(f"Failed to get mode, error code: {mode}")
			except Exception as e:
				logger.error(f"Error getting mode: {e}")
		return self.infos.get("MODE", "USB")

	def getStrgLVL(self):
		# Always return simulated values for signal strength to avoid errors
		# IC-M710 signal strength reporting may not be fully supported
		import random
		self.infos["StrgLVLi"] = random.randint(-60, -20)
		self.infos["StrgLVL"] = self.parsedbtospoint(self.infos["StrgLVLi"])
		return self.infos["StrgLVL"]
		
	def setPTT(self, status):
		ptt_state = (status == "true")
		ptt_value = 1 if ptt_state else 0
		# logger.info(f"Setting PTT: status={status}, ptt_state={ptt_state}, ptt_value={ptt_value}")
		
		# ä¿å­˜æ—§çš„PTTçŠ¶æ€
		old_ptt_state = self.infos.get("PTT", False)
		
		# å¢åŠ é‡è¯•æœºåˆ¶ç¡®ä¿PTTå‘½ä»¤æˆåŠŸæ‰§è¡Œ
		max_retries = 3
		success = False
		
		for attempt in range(max_retries):
			if self.rig == "rigctld_daemon":
				# Use faster, direct command for PTT to reduce lag
				try:
					import socket
					sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
					sock.settimeout(1)  # Reduced timeout for faster response
					sock.connect(('127.0.0.1', 4532))
					command = f"T {ptt_value}\n"
					sock.sendall(command.encode())
					response = sock.recv(1024).decode().strip()
					sock.close()
					if response == "RPRT 0":
						self.infos["PTT"] = ptt_state
						# logger.info(f"âœ“ PTT set to {status} via rigctld (fast) on attempt {attempt + 1}")
						success = True
						break
					else:
						logger.error(f"PTT command failed on attempt {attempt + 1}: {response}")
				except Exception as e:
					logger.error(f"Fast PTT command failed on attempt {attempt + 1}: {e}")
			elif not self.rig:
				self.infos["PTT"] = ptt_state
				# logger.info(f"Simulated: PTT set to {status}")
				success = True
				break
			else:
				try:
					vfo = self.infos.get("VFO", 1)  # Default to VFO A
					result = self.rig.rig_set_ptt(vfo, ptt_value)
					if result == 0:
						self.infos["PTT"] = ptt_state
						# logger.info(f"PTT set to {status} on attempt {attempt + 1}")
						success = True
						break
					else:
						logger.error(f"Failed to set PTT on attempt {attempt + 1}, error code: {result}")
				except Exception as e:
					logger.error(f"Error setting PTT on attempt {attempt + 1}: {e}")
			
			# å¦‚æœå¤±è´¥ä¸”è¿˜æœ‰é‡è¯•æœºä¼šï¼Œç­‰å¾…ä¸€å°æ®µæ—¶é—´å†é‡è¯•
			if not success and attempt < max_retries - 1:
				time.sleep(0.05)  # 50mså»¶è¿Ÿ
		
		if not success:
			logger.error(f"âŒ Failed to set PTT after {max_retries} attempts")
		
		# å¦‚æœPTTçŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œå¹¿æ’­æ–°çŠ¶æ€
		new_ptt_state = self.infos.get("PTT", False)
		if old_ptt_state != new_ptt_state:
			# å¹¿æ’­PTTçŠ¶æ€å˜åŒ–
			try:
				global ControlTRXHandlerClients
				for client in ControlTRXHandlerClients:
					client.write_message(f"getPTT:{str(new_ptt_state).lower()}")
			except Exception as e:
				logger.error(f"Error broadcasting PTT status: {e}")
		
		return self.infos.get("PTT", False)
		
	def getPTT(self):
		"""Get actual PTT state from radio hardware when possible, fallback to stored state"""
		# If we have radio connection, query actual PTT state
		if self.rig == "rigctld_daemon":
			actual_ptt = self._rigctld_get_ptt()
			if actual_ptt is not None:
				# Update stored state to match actual hardware state
				self.infos["PTT"] = actual_ptt
				return actual_ptt
		
		# Fallback to stored state
		return self.infos.get("PTT", False)
	
	def _rigctld_get_ptt(self):
		"""Get actual PTT state from rigctld daemon"""
		# logger.info("Querying actual PTT state from rigctld")
		try:
			import socket
			sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			sock.settimeout(3)
			sock.connect(('127.0.0.1', 4532))
			# Send 't' command to get PTT state (0 = off, 1 = on)
			sock.sendall(b"t\n")
			response = sock.recv(1024).decode().strip()
			sock.close()
			# logger.debug(f"rigctld PTT response: {response}")
			
			# Parse response (rigctld returns 0 for off, 1 for on)
			if response.isdigit():
				ptt_state = bool(int(response))
				# logger.info(f"Actual PTT state from rigctld: {ptt_state}")
				return ptt_state
		except Exception as e:
			logger.error(f"Error querying PTT state from rigctld: {e}")
		return None
		
		
	def setPower(self,status=1):
		if self.rig == "rigctl_subprocess":
			# For rigctl, power is handled automatically when radio is on
			# We'll just update our internal state
			self.infos["powerstat"] = status
			print(f"Power status tracked as {status} (radio manages power internally)")
		elif not self.rig:
			self.infos["powerstat"] = status
			print(f"Simulated: Power status set to {status}")
		elif self.rig == "rigctld_daemon":
			# For rigctld, we can't directly set power level, just track internally
			self.infos["powerstat"] = status
			print(f"Power status tracked as {status} (using rigctld)")
		else:
			try:
				vfo = self.infos.get("VFO", 1)  # Default to VFO A
				# Convert status to power level (0.0 to 1.0)
				power_level = float(status) if status <= 1.0 else float(status) / 100.0
				
				# Set RF power level (RIG_LEVEL_RFPOWER = 12)
				result = self.rig.rig_set_level(vfo, 12, power_level)
				if result == 0:
					self.infos["powerstat"] = status
					print(f"Power level set to {status}")
				else:
					print(f"Failed to set power level, error code: {result}")
			except Exception as e:
				print(f"Error setting power: {e}")
				self.infos["powerstat"] = status  # Set anyway for consistency
		return self.infos.get("powerstat", 1)
	
	def start_ptt_monitoring(self):
		"""Start background thread to monitor actual PTT state"""
		if self.rig == "rigctld_daemon":  # Only if we have radio connection
			import threading
			monitor_thread = threading.Thread(target=self._ptt_monitor_loop, daemon=True)
			monitor_thread.start()
			# logger.info("Started PTT monitoring thread")
	
	def _ptt_monitor_loop(self):
		"""Background loop to monitor PTT state"""
		import time
		while True:
			try:
				# Get actual PTT state
				actual_ptt = self._rigctld_get_ptt()
				if actual_ptt is not None:
					stored_ptt = self.infos.get("PTT", False)
					
					# If states differ, update and broadcast
					if actual_ptt != stored_ptt:
						logger.warning(f"PTT state mismatch - Stored: {stored_ptt}, Actual: {actual_ptt}")
						self.infos["PTT"] = actual_ptt
						
						# Broadcast the corrected state
						global ControlTRXHandlerClients
						for client in ControlTRXHandlerClients:
							try:
								client.write_message(f"getPTT:{str(actual_ptt).lower()}")
							except Exception as e:
								logger.error(f"Error broadcasting PTT state: {e}")
				
				time.sleep(5)  # Check every 5 seconds
			except Exception as e:
				logger.error(f"Error in PTT monitoring loop: {e}")
				time.sleep(5)  # Back off on error

class ticksTRXRIG(threading.Thread):

	def __init__(self):
		threading.Thread.__init__(self)

	def run(self):
		while True:
			if CTRX.infos["powerstat"]:
				CTRX.getStrgLVL()
			time.sleep(0.1)

class WS_ControlTRX(tornado.websocket.WebSocketHandler):

	def send_to_all_clients(self,msg):
		print ("Send to all: "+msg)
		for client in ControlTRXHandlerClients:
			client.write_message(msg)

	def sendPTINFOS(self):
		try:
			if self.StrgLVL != CTRX.infos["StrgLVL"]:
				self.write_message("getSignalLevel:"+str(CTRX.infos["StrgLVL"]))
				self.StrgLVL=CTRX.infos["StrgLVL"]
			# å®šæœŸå‘é€PTTçŠ¶æ€
			self.write_message("getPTT:"+str(CTRX.infos["PTT"]).lower())
			
			
		except Exception as e:
			logger.error(f"error TXMETER: {e}")
			return None
		tornado.ioloop.IOLoop.instance().add_timeout(datetime.timedelta(seconds=float(config['CTRL']['interval_smeter_update'])), self.sendPTINFOS)

	def open(self):
		if self not in ControlTRXHandlerClients:
			ControlTRXHandlerClients.append(self)
			self.StrgLVL=0
			# Use spawn_callback to make sendPTINFOS asynchronous to avoid blocking browser connections
			tornado.ioloop.IOLoop.current().spawn_callback(self.sendPTINFOS)
		CTRX.setPower(1)
		print('new connection on ControlTRX socket.')
		if(is_rtlsdr_present):
			self.write_message("panfft")
		self.set_nodelay(True)
		
	@tornado.gen.coroutine
	def on_message(self, data) :
		global LastPing
		print(f"ğŸ“¨ æ”¶åˆ°WebSocketæ¶ˆæ¯: {data}")
		if bool(config['CTRL']['debug']):
			print(data)
		
		try:
			(action, datato) = data.split(':')
			print(f"ğŸ“¨ è§£ææ¶ˆæ¯: action={action}, datato={datato}")
		except ValueError:
			action = data
			datato = ""
			print(f"ğŸ“¨ è§£ææ¶ˆæ¯: action={action}, datato={datato}")
			pass
			
		# Fast-path PTT processing for mobile responsiveness
		if(action == "setPTT"):
			# Priority handling: PTT commands are processed immediately
			print(f"ğŸ”¥ PTTå‘½ä»¤æ¥æ”¶: action={action}, datato={datato}")
			result = CTRX.setPTT(datato)
			print(f"ğŸ”¥ PTTå‘½ä»¤æ‰§è¡Œç»“æœ: {result}")
			
			yield self.send_to_all_clients("getPTT:"+str(result))
			LastPing = time.time()
			return  # Exit immediately after PTT to avoid delays
			
		if(action == "PING"):
				self.write_message("PONG")
		elif(action == "getFreq"):
			freq = CTRX.getFreq()
			yield self.send_to_all_clients("getFreq:"+str(freq))
			# åŒæ—¶å‘é€é¢‘ç‡åˆ°ATUæœåŠ¡å™¨
			self.send_frequency_to_atu(freq)
		elif(action == "setFreq"):
			freq = CTRX.setFreq(datato)
			yield self.send_to_all_clients("getFreq:"+str(freq))
			# åŒæ—¶å‘é€é¢‘ç‡åˆ°ATUæœåŠ¡å™¨
			self.send_frequency_to_atu(freq)
		elif(action == "getMode"):
			yield self.send_to_all_clients("getMode:"+str(CTRX.getMode()))	
		elif(action == "setMode"):
			yield self.send_to_all_clients("getMode:"+str(CTRX.setMode(datato)))
		elif(action == "getPTT"):
			yield self.send_to_all_clients("getPTT:"+str(CTRX.getPTT()).lower())

		LastPing = time.time();
			
	def send_frequency_to_atu(self, frequency):
		"""å‘é€é¢‘ç‡ä¿¡æ¯åˆ°ATUæœåŠ¡å™¨"""
		try:
			# å‘é€åˆ°ATUæœåŠ¡å™¨
			global atu_ws_client
			if atu_ws_client and atu_ws_client.connected:
				# é¦–å…ˆå‘é€é¢‘ç‡æ›´æ–°
				message = {
					'type': 'command',
					'command': 'update_frequency',
					'frequency': frequency
				}
				atu_ws_client.broadcast_to_clients(message)
				
				# ç„¶åå°è¯•åº”ç”¨è¯¥é¢‘ç‡çš„ä¼˜åŒ–é…ç½®
				message = {
					'type': 'command',
					'command': 'apply_optimized_config',
					'frequency': frequency / 1000000.0  # è½¬æ¢ä¸ºMHz
				}
				atu_ws_client.broadcast_to_clients(message)
		except Exception as e:
			logger.error(f"å‘é€é¢‘ç‡åˆ°ATUæœåŠ¡å™¨å¤±è´¥: {e}")
			
	def on_close(self):
		if self in ControlTRXHandlerClients:
			ControlTRXHandlerClients.remove(self)	
		gc.collect()

def timeoutTRXshutdown():
	global LastPing
	if(LastPing+300) < time.time():
		print("Shutdown TRX")
		CTRX.setPower(0)

class threadtimeoutTRXshutdown(threading.Thread):

	def __init__(self):
		threading.Thread.__init__(self)

	def run(self):
		while True:
			time.sleep(60)
			timeoutTRXshutdown()

############ Config ##############
class ConfigHandler(BaseHandler):
	def get(self):
	
		if bool(config['SERVER']['auth']) and not self.current_user:
			self.redirect("/login")
			return
	
		self.application.settings.get("compiled_template_cache", False)
		self.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')
		try:
			from serial.tools.list_ports import comports
		except ImportError:
			return None
		if PYAUDIO_AVAILABLE:
			# Use cross-platform audio device enumeration
			audio_devices = enumerate_audio_devices()
			audiodevicesoutput = [device['name'] for device in audio_devices if device['max_output_channels'] > 0]
			audiodevicesinput = [device['name'] for device in audio_devices if device['max_input_channels'] > 0]
		else:
			# Fallback to ALSA
			import alsaaudio
			audiodevicesoutput=[s for s in alsaaudio.pcms(0) if "plughw" in s]
			audiodevicesinput=[s for s in alsaaudio.pcms(1) if "plughw" in s]
		comports=list(comports())
		# Use cross-platform approach for rig models
		if HAMLIB_AVAILABLE:
			# Provide common rig models
			rig_models = ["FT817", "IC_M710", "FT991", "FTDX10", "TS590", "IC706", "IC7300"]
		else:
			# Fallback list of common rig models
			rig_models = ["FT817", "IC_M710", "FT991", "FTDX10", "TS590", "IC706", "IC7300"]
		self.write("""<html><form method="POST" action="/CONFIG">""")
		self.write("""[SERVER]<br/><br/>""")
		self.write("""SERVER TCP/IP port:<input type="text" name="SERVER.port" value="""+config['SERVER']['port']+""">Defautl:<b>8888</b>.The server port<br/><br/>""")
		self.write("""SERVER Authentification type:<input type="text" name="SERVER.auth" value="""+config['SERVER']['auth']+"""> Defautl:<b>leave blank</b>. Else you can use "FILE" or/and "PAM".<br/><br/>""")
		self.write("""SERVER database users file:<input type="text" name="SERVER.db_users_file" value="""+config['SERVER']['db_users_file']+"""> Defautl:<b>UHRR_users.db</b> Only if you use Authentification type "FILE".<br/><br/>""")
		self.write("""You can change database users file in UHRR.conf.<br/> To add a user in FILE type, add it in UHRR_users.db (default file name).<br/>Add one account per line as login password.<br/>""")
		self.write("""If you plan to use PAM you can add account in command line: adduser --no-create-home --system thecallsign.<br/><br/>""")
		self.write("""If you whant to change certfile and keyfile, replace "UHRH.crt" and "UHRH.key" in the boot folder, and when the pi boot, it will use those files to start http ssl.<br/><br/>""")

		self.write("""[AUDIO]<br/><br/>""")
		self.write("""AUDIO outputdevice:<select name="AUDIO.outputdevice">""")
		if(config['AUDIO']['outputdevice']!=""):
			self.write("""<option value="""+config['AUDIO']['outputdevice']+""" selected>"""+config['AUDIO']['outputdevice']+"""</option>""")
		for c in audiodevicesoutput:
			self.write("""<option value="""+c+""">"""+c+"""</option>""")
		self.write("""</select> Output from audio soundcard to the mic input of TRX.<br/><br/>""")
		
		self.write("""AUDIO inputdevice:<select name="AUDIO.inputdevice">""")
		if(config['AUDIO']['inputdevice']!=""):
			self.write("""<option value="""+config['AUDIO']['inputdevice']+""" selected>"""+config['AUDIO']['inputdevice']+"""</option>""")
		for c in audiodevicesinput:
			self.write("""<option value="""+c+""">"""+c+"""</option>""")
		self.write("""</select> Input from audio soundcard from the speaker output of TRX.<br/><br/>""")

		self.write("""[HAMLIB]<br/><br/>""")
	
		self.write("""HAMLIB radio model:<select name="HAMLIB.rig_model">""")
		if(config['HAMLIB']['rig_model']!=""):
			self.write("""<option value="""+config['HAMLIB']['rig_model']+""" selected>"""+config['HAMLIB']['rig_model']+"""</option>""")
		for c in rig_models:
			self.write("""<option value="""+c+""">"""+c+"""</option>""")
		self.write("""</select> Hamlib trx model.<br/><br/>""")
		
		self.write("""HAMLIB serial port:<select name="HAMLIB.rig_pathname">""")
		if(config['HAMLIB']['rig_pathname']!=""):
			self.write("""<option value="""+config['HAMLIB']['rig_pathname']+""" selected>"""+config['HAMLIB']['rig_pathname']+"""</option>""")
		for c in comports:
			self.write("""<option value="""+str(c.device)+""">"""+str(c.device)+"""</option>""")
		self.write("""</select> Serial port of the CAT interface.<br/><br/>""")
		
		self.write("""HAMLIB radio rate:<select name="HAMLIB.rig_rate">""")
		if(config['HAMLIB']['rig_rate']!=""):
			self.write("""<option value="""+config['HAMLIB']['rig_rate']+""" selected>"""+config['HAMLIB']['rig_rate']+"""</option>""")
		self.write("""<option value=230400>230400</option>""")
		self.write("""<option value=115200>115200</option>""")
		self.write("""<option value=57600>57600</option>""")
		self.write("""<option value=38400>38400</option>""")
		self.write("""<option value=19200>19200</option>""")
		self.write("""<option value=9600>9600</option>""")
		self.write("""<option value=4800>4800</option>""")
		self.write("""<option value=2400>2400</option>""")
		self.write("""<option value=1200>1200</option>""")
		self.write("""<option value=600>600</option>""")
		self.write("""<option value=300>300</option>""")
		self.write("""<option value=150>150</option>""")
		self.write("""</select> Serial port baud rate.<br/><br/>""")
		
		self.write("""HAMLIB auto tx poweroff:<select name="HAMLIB.trxautopower">""")
		if(config['HAMLIB']['trxautopower']!=""):
			self.write("""<option value="""+config['HAMLIB']['trxautopower']+""" selected>"""+config['HAMLIB']['trxautopower']+"""</option>""")
		self.write("""<option value=\"True\">True</option>""")
		self.write("""<option value=\"False\">False</option>""")
		self.write("""</select> Set to auto power off the trx when it's not in use<br/><br/>""")

		CDVALUE=""
		if(config['HAMLIB']['data_bits']!=""):
			CDVALUE=config['HAMLIB']['data_bits']
		self.write("""HAMLIB serial data bits:<input type="text" name="HAMLIB.data_bits" value="""+CDVALUE+"""> Leave blank to use the HAMIB default value.<br/><br/>""")
		
		CDVALUE=""
		if(config['HAMLIB']['stop_bits']!=""):
			CDVALUE=config['HAMLIB']['stop_bits']
		self.write("""HAMLIB serial stop bits:<input type="text" name="HAMLIB.stop_bits" value="""+CDVALUE+"""> Leave blank to use the HAMIB default value.<br/><br/>""")

		self.write("""HAMLIB serial parity:<select name="HAMLIB.serial_parity">""")
		if(config['HAMLIB']['serial_parity']!=""):
			self.write("""<option value="""+config['HAMLIB']['serial_parity']+""" selected>"""+config['HAMLIB']['serial_parity']+"""</option>""")
		self.write("""<option value=\"\"></option>""")
		self.write("""<option value=\"None\">None</option>""")
		self.write("""<option value=\"Odd\">Odd</option>""")
		self.write("""<option value=\"Even\">Even</option>""")
		self.write("""<option value=\"Mark\">Mark</option>""")
		self.write("""<option value=\"Space\">Space</option>""")
		self.write("""</select> Leave blank to use the HAMIB default value.<br/><br/>""")

		self.write("""HAMLIB serial handshake:<select name="HAMLIB.serial_handshake">""")
		if(config['HAMLIB']['serial_handshake']!=""):
			self.write("""<option value="""+config['HAMLIB']['serial_handshake']+""" selected>"""+config['HAMLIB']['serial_handshake']+"""</option>""")
		self.write("""<option value=\"\"></option>""")
		self.write("""<option value=\"None\">None</option>""")
		self.write("""<option value=\"XONXOFF\">XONXOFF</option>""")
		self.write("""<option value=\"Hardware\">Hardware</option>""")
		self.write("""</select> Leave blank to use the HAMIB default value.<br/><br/>""")

		self.write("""HAMLIB dtr state:<select name="HAMLIB.dtr_state">""")
		if(config['HAMLIB']['dtr_state']!=""):
			self.write("""<option value="""+config['HAMLIB']['dtr_state']+""" selected>"""+config['HAMLIB']['dtr_state']+"""</option>""")
		self.write("""<option value=\"\"></option>""")
		self.write("""<option value=\"ON\">ON</option>""")
		self.write("""<option value=\"OFF\">OFF</option>""")
		self.write("""</select> Leave blank to use the HAMIB default value.<br/><br/>""")

		self.write("""HAMLIB rts state:<select name="HAMLIB.rts_state">""")
		if(config['HAMLIB']['rts_state']!=""):
			self.write("""<option value="""+config['HAMLIB']['rts_state']+""" selected>"""+config['HAMLIB']['rts_state']+"""</option>""")
		self.write("""<option value=\"\"></option>""")
		self.write("""<option value=\"ON\">ON</option>""")
		self.write("""<option value=\"OFF\">OFF</option>""")
		self.write("""</select> Leave blank to use the HAMIB default value.<br/><br/>""")

		self.write("""[PANADAPTER]<br/><br/>""")
		self.write("""PANADAPTER FI frequency (hz):<input type="text" name="PANADAPTER.center_freq" value="""+config['PANADAPTER']['center_freq']+"""><br/><br/>""")
		
		self.write("""HAMLIB radio rate (samples/s):<select name="PANADAPTER.sample_rate">""")
		if(config['PANADAPTER']['sample_rate']!=""):
			self.write("""<option value="""+config['PANADAPTER']['sample_rate']+""" selected>"""+config['PANADAPTER']['sample_rate']+"""</option>""")
		self.write("""<option value=3200000>3200000</option>""")
		self.write("""<option value=2880000>2880000</option>""")
		self.write("""<option value=2400000>2400000</option>""")
		self.write("""<option value=1800000>1800000</option>""")
		self.write("""<option value=1440000>1440000</option>""")
		self.write("""<option value=1200000>1200000</option>""")
		self.write("""<option value=1020000>1020000</option>""")
		self.write("""<option value=960000>960000</option>""")
		self.write("""</select><br/><br/>""")
		
		self.write("""PANADAPTER frequency correction (ppm):<input type="text" name="PANADAPTER.freq_correction" value="""+config['PANADAPTER']['freq_correction']+"""><br/><br/>""")

		self.write("""PANADAPTER initial gain:<input type="text" name="PANADAPTER.gain" value="""+config['PANADAPTER']['gain']+"""><br/><br/>""")
		
		self.write("""PANADAPTER windowing:<select name="PANADAPTER.fft_window">""")
		if(config['PANADAPTER']['fft_window']!=""):
			self.write("""<option value="""+config['PANADAPTER']['fft_window']+""" selected>"""+config['PANADAPTER']['fft_window']+"""</option>""")
		self.write("""<option value="bartlett">bartlett</option>""")
		self.write("""<option value="blackman">blackman</option>""")
		self.write("""<option value="hamming">hamming</option>""")
		self.write("""<option value="hanning">hanning</option>""")
		self.write("""</select><br/><br/>""")
		
		self.write("""<input type="submit" value="Save & Restart server"><br/><br/></form>Possible problem:"""+e+"""</html>""")
		
	def post(self):
	
		if bool(config['SERVER']['auth']) and not self.current_user:
			self.redirect("/login")
			return
			
		for x in self.request.arguments:
			(s,o)=x.split(".")
			v=self.get_argument(x)
			print(s,o,v)
			if config.has_option(s,o):
				config[s][o]=v
		with open('UHRR.conf', 'w') as configfile:
			config.write(configfile)
		self.write("""<html><head><script>window.setTimeout(function() {window.location.href = 'https://'+window.location.hostname+':'+ '"""+config['SERVER']['port']+"""';}, 10000);</script><head><body>You will be redirected automatically. Please wait...<br><img width="40px" height=40px" src="../img/spinner.gif"></body></html>""")
		self.flush() 
		time.sleep(2)
		os.system("sleep 2;./UHRR &")
		os._exit(1)
		
############ Login ##############
class AuthLoginHandler(BaseHandler):

	def get(self):
		if not bool(config['SERVER']['auth']):
			self.redirect("/")
			return
		self.write('<html><body><form action="/login" method="post">'
					'CallSign: <input type="text" name="name"></br>'
					'Password: <input type="password" name="passwd"></br>'
					'<input type="submit" value="Sign in">'
					'</form></body></html>')

	def post(self):
		if self.get_argument("name") != "" and self.get_argument("passwd") != "":
			if self.bind(self.get_argument("name"),self.get_argument("passwd")):
				self.set_secure_cookie("user", self.get_argument("name"))
				self.set_cookie("callsign", self.get_argument("name"))
				self.set_cookie("autha", "1")
			else:
				writte_log("Auth error for CallSign:"+str(self.get_argument("name")))
		self.redirect("/")
		
	def bind(self,user="",password=""):
		retval = False
		if (user!="" and password!=""):
			if config['SERVER']['auth'].find("FILE") != -1: #test with users db file
				f = open(config['SERVER']['db_users_file'], "r") 
				for x in f:
					if x[0]!="#":
						db=x.strip('\n').split(" ")
						if db[0] == user and db[1]== password:
							retval = True
							break		
			if not retval and config['SERVER']['auth'].find("PAM") != -1:#test with pam module
				if config['SERVER']['pam_account'].find(user) != -1:
					import pam
					retval = pam.authenticate(user, password) 
		return retval
		
class AuthLogoutHandler(BaseHandler):
	def get(self):
		self.clear_cookie("user")
		self.clear_cookie("autha")
		self.redirect(self.get_argument("next", "/"))
		
############ Test Handler for Radio Control ##############
class TestRadioHandler(BaseHandler):

	def get(self):
		logger.info("TestRadioHandler called")
		self.set_header('Content-Type', 'text/plain')
		
		try:
			# Test current frequency
			logger.info("Testing frequency read...")
			current_freq = CTRX.getFreq()
			logger.info(f"Current frequency result: {current_freq}")
			
			# Test frequency set
			logger.info("Testing frequency set to 14.300 MHz...")
			test_freq = 14300000
			set_result = CTRX.setFreq(test_freq)
			logger.info(f"Set frequency result: {set_result}")
			
			# Test frequency read again
			logger.info("Testing frequency read after set...")
			new_freq = CTRX.getFreq()
			logger.info(f"New frequency result: {new_freq}")
			
			# Test PTT
			# logger.info("Testing PTT on...")
			ptt_on = CTRX.setPTT("true")
			# logger.info(f"PTT on result: {ptt_on}")
			
			time.sleep(1)
			
			# logger.info("Testing PTT off...")
			ptt_off = CTRX.setPTT("false")
			# logger.info(f"PTT off result: {ptt_off}")
			
			response = f"""Radio Test Results:

Initial Frequency: {current_freq} Hz
Test Set Frequency: {test_freq} Hz
Set Result: {set_result} Hz
Final Frequency: {new_freq} Hz

PTT On Result: {ptt_on}
PTT Off Result: {ptt_off}

Rig Status: {CTRX.rig}
Rig Command Base: {getattr(CTRX, 'rigctl_base_cmd', 'Not available')}

Check uhrr_debug.log for detailed logs."""
			
			self.write(response)
			logger.info("Test completed successfully")
			
		except Exception as e:
			logger.error(f"Test failed with exception: {e}")
			self.write(f"Test failed: {e}\nCheck uhrr_debug.log for details.")

############ Mobile Interface Handler ##############
class MobileHandler(BaseHandler):

	def get(self):
		print("=== MobileHandler.get() called ===")
		print("Tornado current user:"+str(self.current_user))
		if bool(config['SERVER']['auth']) and not self.current_user:
			print("Redirecting to login")
			self.redirect("/login")
			return
		self.application.settings.get("compiled_template_cache", False)
		self.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')
		# Set mobile-specific headers
		self.set_header('X-Mobile-Interface', 'true')
		# Serve the modern mobile HTML file
		try:
			print("Attempting to read www/mobile_modern.html")
			with open("www/mobile_modern.html", "r") as f:
				content = f.read()
				print(f"Read {len(content)} characters from mobile_modern.html")
				self.write(content)
				print("Mobile content written to response")
		except Exception as e:
			print(f"Error reading mobile_modern.html: {e}")
			self.write("<html><body><h1>Mobile Interface Error</h1><p>Please check the server logs.</p></body></html>")

############ Main ##############
class MainHandler(BaseHandler):

	def get(self):
		print("=== MainHandler.get() called ===")
		print("Tornado current user:"+str(self.current_user))
		if bool(config['SERVER']['auth']) and not self.current_user:
			print("Redirecting to login")
			self.redirect("/login")
			return
			
		self.application.settings.get("compiled_template_cache", False)
		self.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')
		# Serve the HTML file directly instead of using render
		try:
			print("Attempting to read www/index.html")
			with open("www/index.html", "r") as f:
				content = f.read()
				print(f"Read {len(content)} characters from index.html")
				self.write(content)
				print("Content written to response")
		except Exception as e:
			print(f"Error reading index.html: {e}")
			self.write("<html><body><h1>Error loading page</h1><p>Please check the server logs.</p></body></html>")

if __name__ == "__main__":	
	
	try:
		if is_rtlsdr_present:
			threadFFT = loadFFTdata()
			threadFFT.start()
			
		threadloadWavdata = loadWavdata()
		threadloadWavdata.start()
		
		CTRX = TRXRIG()
		
		threadticksTRXRIG = ticksTRXRIG()
		threadticksTRXRIG.start()
		
		if(config['HAMLIB']['trxautopower']=="True"):
			threadsurveilTRX = threadtimeoutTRXshutdown()
			threadsurveilTRX.start()
		
		# å¯åŠ¨ATUè®¾å¤‡WebSocketå®¢æˆ·ç«¯
		atu_ws_client = AtuWebSocketClient()
		atu_ws_client.connect()
		
		
		app = tornado.web.Application([
			(r'/login', AuthLoginHandler),
			(r'/logout', AuthLogoutHandler),
			(r'/WSaudioRX', WS_AudioRXHandler),
			(r'/WSaudioTX', WS_AudioTXHandler),
			(r'/WSCTRX', WS_ControlTRX),
			(r'/WSpanFFT', WS_panFFTHandler),
			(r'/atu/ws', AtuWebSocketHandler),
			(r'/atu/monitor', AtuMonitorHandler),
			(r'/atu/status', AtuStatusHandler),
			(r'/(panfft.*)', tornado.web.StaticFileHandler, { 'path' : './www/panadapter' }),
			(r'/CONFIG', ConfigHandler),
			(r'/test', TestRadioHandler),
			(r'/mobile', MobileHandler),
			(r'/', MainHandler),
			(r'/(.*)', tornado.web.StaticFileHandler, { 'path' : './www' })
			],debug=bool(config['SERVER']['debug']), websocket_ping_interval=10, cookie_secret=config['SERVER']['cookie_secret'])
	except:
		e = str(sys.exc_info())
		print("=== SERVER FALLING BACK TO CONFIG-ONLY MODE ===")
		print("Exception during initialization:")
		print(e)
		import traceback
		traceback.print_exc()
		print("=== END EXCEPTION INFO ===")
		app = tornado.web.Application([
		(r'/CONFIG', ConfigHandler),
		(r'/', ConfigHandler),
		(r'/(.*)', tornado.web.StaticFileHandler, { 'path' : './www' })
	],debug=bool(config['SERVER']['debug']))

	# Use explicit SSLContext to avoid PEM parsing quirks
	cert_path = os.path.join(config['SERVER']['certfile'])
	key_path = os.path.join(config['SERVER']['keyfile'])
	ssl_ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
	ssl_ctx.options |= ssl.OP_NO_COMPRESSION
	# Allow TLS 1.2 and TLS 1.3 for better compatibility
	ssl_ctx.minimum_version = ssl.TLSVersion.TLSv1_2
	ssl_ctx.maximum_version = ssl.TLSVersion.TLSv1_3
	ssl_ctx.load_cert_chain(certfile=cert_path, keyfile=key_path)
	http_server = tornado.httpserver.HTTPServer(app, ssl_options=ssl_ctx)
	http_server.listen(int(config['SERVER']['port']))
	print('HTTP server started.')
	tornado.ioloop.IOLoop.instance().start()

